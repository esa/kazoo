@@-- The following tags are available in this template:
@@--
@@-- @_Name_@            : Partition name (usually the name of the binary)
@@-- @_Threads_@         : Code generated for the threads
@@-- @_Thread_Names_@    : Tag: list of thread names
@@-- @_Node_Name_@       : Name of the node containing this partition
@@-- @_Blocks_@          : Code generated for protected functions
@@-- @_Block_Names@      : Vector Tag: list of block (user functions) names
@@-- @_Block_Languages@  :   |_ Corresponding implementation language
@@-- @_Coverage_@        : True if user requested code coverage enable
@@-- @_Package_Name_@    : AADL Package name for the target (e.g. ocarina_porocessors_x86)
@@-- @_CPU_Name_@        : CPU Name (e.g. x86_linux)
@@-- @_CPU_Platform_@    : AADL CPU_Platform (e.g. PLATFORM_NATIVE)
@@-- @_CPU_Classifier_@  : AADL CPU Classifier (e.g. ocarina_processors_x86::x86.linux)
@@-- @_VP_Name_@         : Virtual processor name on which the partition is bounded
@@-- @_VP_Platform_@     : Virtual processor platform (e.g. PLATFORM_AIR)
@@-- @_VP_Classifier_@   : Virtual processor classifier
@@-- @_Ada_Runtime_@     : Set if CPU_Platform = PLATFORM_GNAT_RUNTIME
@@-- @_Bound_Functions_@ : List of user functions from Interface view
@@-- @_Thread_Src_Name_@ : Vector tag : connection thread name (source)
@@-- @_Thread_Dst_Name_@ : Vector tag : connection thread name (dest)
@@-- @_Thread_Src_Port_@ : Vector tag : connection port name (source)
@@-- @_Thread_Dst_Port_@ : Vector tag : connection port name (dest)
@@-- @_In_Port_Names_@        : Vector tag: input ports of the partition
@@-- @_In_Port_Thread_Name_@  :     |_ corresponding thread inside the partition
@@-- @_In_Port_Type_Name_@    :     |_ corresponding parameter type name (optional)
@@-- @_Out_Port_Names_@       : Vector tag: output ports of the partition
@@-- @_Out_Port_Thread_Name_@ :     |_ corresponding thread inside the partition
@@-- @_Out_Port_Type_Name_@   :     |_ corresponding parameter type name (optional)
/* File generated by kazoo for TASTE - do not edit */
#include <msp430.h>

#include <stdint.h>
#include "FreeRTOS.h"
#include "task.h"
#include "semphr.h"
#include "timers.h"

#include "msp430_partition_interface.h"
#include "transport.h"

@@TABLE@@
#include "drivers/@_Device_Names_@/@_Device_Names_@.h"
@@END_TABLE@@

@@TABLE@@
#include "thread_@_LOWER:Thread_Names_@.h"
@@END_TABLE@@

@@TABLE@@
extern void init_@_LOWER:Bound_Functions_@(void);
@@END_TABLE@@

@@TABLE@@
__attribute__ ((persistent)) SemaphoreHandle_t @_LOWER:Bound_Functions_@_semaphore;
__attribute__ ((persistent)) StaticSemaphore_t prv_@_LOWER:Bound_Functions_@_mutex_buffer;
@@END_TABLE@@

@@TABLE@@
//QueueHandle_t @_Thread_Names_@_global_queue = NULL;
@@END_TABLE@@

@_Threads_@

// heap declaration
// __attribute__ ((persistent)) uint8_t ucHeap[configTOTAL_HEAP_SIZE] = { 0 };

// function to setup hardware
static void prvSetupHardware()
{
    // stop watchdog timer
    WDTCTL = WDTPW | WDTHOLD;

    PM5CTL0 &= ~LOCKLPM5;

    // Unlock clock registers
    CSCTL0_H = CSKEY >> 8;

    // Set DCO to 8MHz
    CSCTL1 = DCOFSEL_3 | DCORSEL;

    // select LFXTCLK for ACLK
    // select DCO for SMCLK
    // select DCO for MCLK
    CSCTL2 = SELA__LFXTCLK | SELS__DCOCLK | SELM__DCOCLK;

    // Set all dividers
    CSCTL3 = DIVA__1 | DIVS__1 | DIVM__1;

    // Lock clock registers
    CSCTL0_H = 0;

    // initialize devices
@@TABLE@@
    @_Device_Init_@();
@@END_TABLE@@
}


// stack overflow handler
void vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName)
{
    (void) pcTaskName;
    (void) pxTask;

    /* Run time stack overflow checking is performed if
     configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
     function is called if a stack overflow is detected.
     See http://www.freertos.org/Stacks-and-stack-overflow-checking.html */

    /* Force an assert. */
    configASSERT(( volatile void * ) NULL);
}

// MSP-430 timers setup
void vApplicationSetupTimerInterrupt(void)
{
    const unsigned short usACLK_Frequency_Hz = 32768;

    /* Ensure the timer is stopped. */
    TA0CTL = 0;

    /* Run the timer from the ACLK. */
    TA0CTL = TASSEL_1;

    /* Clear everything to start with. */
    TA0CTL |= TACLR;

    /* Set the compare match value according to the tick rate we want. */
    TA0CCR0 = usACLK_Frequency_Hz / configTICK_RATE_HZ;

    /* Enable the interrupts. */
    TA0CCTL0 = CCIE;

    /* Start up clean. */
    TA0CTL |= TACLR;

    /* Up mode. */
    TA0CTL |= MC_1;
}

__attribute__ ((persistent)) StaticTask_t xIdleTaskTCB;
__attribute__ ((persistent)) StackType_t xIdleTaskStack[configMINIMAL_STACK_SIZE] = {0};

void vApplicationGetIdleTaskMemory(StaticTask_t** ppxIdleTaskPCBBuffer,
                                   StackType_t** ppxIdleTaskStackBuffer,
                                   uint32_t* pulIdleTaskStackSize)
{

    *ppxIdleTaskPCBBuffer = &xIdleTaskTCB;
    *ppxIdleTaskStackBuffer = xIdleTaskStack;
    *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
}

__attribute__ ((persistent)) StaticTask_t xTimerTaskTCB;
__attribute__ ((persistent)) StackType_t xTimerTaskStack[configMINIMAL_STACK_SIZE] = {0};

void vApplicationGetTimerTaskMemory(StaticTask_t** ppxTimerTaskPCBBuffer,
                                   StackType_t** ppxTimerTaskStackBuffer,
                                   uint32_t* pulTimerTaskStackSize)
{

    *ppxTimerTaskPCBBuffer = &xTimerTaskTCB;
    *ppxTimerTaskStackBuffer = xTimerTaskStack;
    *pulTimerTaskStackSize = configMINIMAL_STACK_SIZE;
}

// the main function
int main(void)
{
    prvSetupHardware();

@@TABLE@@
    @_LOWER:Bound_Functions_@_semaphore = xSemaphoreCreateMutexStatic(&prv_@_LOWER:Bound_Functions_@_mutex_buffer);
    init_@_LOWER:Bound_Functions_@();
@@END_TABLE@@

@@-- @_Threads_@

@@TABLE@@
    initialize_thread_@_LOWER:Thread_Names_@();
@@END_TABLE@@

    vTaskStartScheduler();

    for(;;);
}
