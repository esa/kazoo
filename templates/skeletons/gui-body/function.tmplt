@@-- The following tags are available in this template:
@@--
@@-- @_Name_@                : The name of the function
@@-- @_Language_@            : The implementation language
@@-- @_List_Of_PIs_@         : List of all Provided Interfaces (just names)
@@-- @_List_Of_RIs_@         : List of all Required Interfaces (just names)
@@-- @_List_Of_Sync_PIs@     : List of synchronous Provided Interfaces
@@-- @_List_Of_Sync_RIs@     : List of synchronous Required Interfaces
@@-- @_Sync_RIs_Parent_@
@@-- @_List_Of_ASync_PIs@    : Vector tag: list of async Provided Interfaces
@@-- @_ASync_PI_Param_Name_@ :   |_ Corresponding parameter name (or empty string)
@@-- @_ASync_PI_Param_Type_@ :   |_ Corresponding parameter type (or empty string)
@@-- @_List_Of_ASync_RIs@    : Vector tag: list of asynchronous Required Interfaces
@@-- @_ASync_RI_Param_Name_@ :   |_ Corresponding parameter name (or empty string)
@@-- @_ASync_RI_Param_Type_@ :   |_ Corresponding parameter type (or empty string)
@@-- @_Async_RIs_Parent_@    :   |_ Corresponding parent function
@@-- @_ASN1_Modules_@        : List of ASN.1 Modules names
@@-- @_ASN1_Files_@          : List of ASN.1 Files with path
@@-- @_Timers_@              : List of timers (just names)
@@-- @_Has_Context_@         : Flag, True if there are context parameters
@@-- @_CP_Names_@            : List of Context Parameter names
@@-- @_CP_Types_@            : List of Context Parameter types
@@-- @_Provided_Interfaces_@ : From template: Provided interfaces with params
@@-- @_Required_Interfaces_@ : From template: Required interfaces with params
@@-- @_Property_Names_@      : List of User-defined properties (names)
@@-- @_Property_Values_@     : List of User-defined properties (values)
@@-- @_Is_Type_@             : Flag, True if function is a component type
@@-- @_Instance_Of_@         : Optional name of component type
/* Body file for GUI @_Name_@
 * Generated by TASTE on @_NOW_@
 * DO NOT EDIT THIS FILE MANUALLY - MODIFY THE KAZOO TEMPLATE IF NECESSARY
*/

#include <unistd.h>
#include <mqueue.h>

#include "queue_manager.h"
#include "@_LOWER:Name_@.h"
#include "@_Name_@_enums_def.h"

typedef struct _PI_Messages {
   T_@_Name_@_PI_list msg_id;
   union {
      @@TABLE@@
      @@IF@@ @_ASync_PI_Param_Type_@ /= ""
      asn1Scc@_REPLACE_ALL(-/_):ASync_PI_Param_Type_@ @_LOWER:List_Of_ASync_PIs_@_param;
      @@END_IF@@
      @@END_TABLE@@
   } msg_data;
} PI_Messages;

typedef struct _RI_Messages {
   T_@_Name_@_RI_list msg_id;
   union {
      @@TABLE@@
      @@IF@@ @_ASync_RI_Param_Type_@ /= ""
      asn1Scc@_REPLACE_ALL(-/_):ASync_RI_Param_Type_@ @_LOWER:List_Of_ASync_RIs_@_param;
      @@END_IF@@
      @@END_TABLE@@
   } msg_data;
} RI_Messages;

@@IF@@ @_List_Of_PIs'Length_@ > 0
// Queues of messages going from the binary to the user (PIs, or TMs)
static mqd_t @_LOWER:Name_@_PI_queue_id,
             @_LOWER:Name_@_PI_Python_queue_id;
@@END_IF@@

@@IF@@ @_List_Of_PIs'Length_@ > 0
// Queues of messages going from the user to the binary GUI (RIs, or TCs)
static mqd_t @_LOWER:Name_@_RI_queue_id;
@@END_IF@@


void @_LOWER:Name_@_startup(void)
{
   unsigned msgsize_max = 8192;
   FILE *f = fopen("/proc/sys/fs/mqueue/msgsize_max", "r");
   fscanf(f, "%d", &msgsize_max);

   if (msgsize_max < sizeof (PI_Messages) || msgsize_max < sizeof (RI_Messages)) {
      printf("[ERROR] The GUI is passing a message which parameter size "
             "exceeds your system limit (which is %d bytes per message).\n"
             "You can extend this limit by running: \n"
             "    echo NUMBER | sudo tee /proc/sys/fs/mqueue/msgsize_max\n"
             " ...  with NUMBER > %ld\n"
             "You can also make it permanent (check TASTE wiki)\n\n",
             msgsize_max,
             sizeof(PI_Messages) > sizeof(RI_Messages) ? sizeof(PI_Messages):sizeof(RI_Messages));
      exit(1);
   }

    char *gui_queue_name = NULL;
    int  len = snprintf (gui_queue_name, 0, "%d_@_LOWER:Name_@_RI_queue", geteuid());
    gui_queue_name = (char *) malloc ((size_t) len + 1);
    if (NULL != gui_queue_name) {
       snprintf (gui_queue_name, len + 1, "%d_@_LOWER:Name_@_RI_queue", geteuid());

       create_exchange_queue(gui_queue_name, 5, sizeof(RI_Messages), &@_LOWER:Name_@_RI_queue_id);

       free (gui_queue_name);
       gui_queue_name = NULL;
    }

    len = snprintf (gui_queue_name, 0, "%d_@_LOWER:Name_@_PI_queue", geteuid());
    gui_queue_name = (char *) malloc ((size_t) len + 1);
    if (NULL != gui_queue_name) {
       snprintf (gui_queue_name, len + 1, "%d_@_LOWER:Name_@_PI_queue", geteuid());

       create_exchange_queue(gui_queue_name, 10, sizeof(PI_Messages), &@_LOWER:Name_@_PI_queue_id);

       free (gui_queue_name);
       gui_queue_name = NULL;
    }

    len = snprintf (gui_queue_name, 0, "%d_@_LOWER:Name_@_PI_Python_queue", geteuid());
    gui_queue_name = (char *) malloc ((size_t) len + 1);
    if (NULL != gui_queue_name) {
       snprintf (gui_queue_name, len + 1, "%d_@_LOWER:Name_@_PI_Python_queue", geteuid());

       /* Extra queue for the TM sent to the Python mappers */
       create_exchange_queue(gui_queue_name, 10, sizeof (PI_Messages), &@_LOWER:Name_@_PI_Python_queue_id);

       free (gui_queue_name);
       gui_queue_name = NULL;
    }
}

//  Function polling the message queue for incoming message from the user
void @_LOWER:Name_@_PI_poll(void)
{
   struct mq_attr msgq_attr;
   char* msgcontent = NULL;

   T_@_Name_@_RI_list message_received_type;

   if ((msgcontent = (char*)malloc(sizeof(RI_Messages))) == NULL) {
      perror("Error when allocating memory in GUI polling function");
      exit (-1);
   }

   mq_getattr(@_LOWER:Name_@_RI_queue_id, &msgq_attr);

   while (!retrieve_message_from_queue(@_LOWER:Name_@_RI_queue_id,
                                       sizeof(RI_Messages),
                                       msgcontent,
                                       (int *)&message_received_type)) {
      switch(message_received_type) {
@@TABLE@@
         case i_@_List_Of_ASync_RIs_@:
            @_LOWER:Name_@_RI_@_LOWER:List_Of_ASync_RIs_@((asn1Scc@_REPLACE_ALL(-/_):ASync_RI_Param_Type_@ *)msgcontent);
            break;
@@END_TABLE@@
       default : break;
      }
   }

   free(msgcontent);
   return;
}

@@TABLE@@
@_Provided_Interfaces_@

@@END_TABLE@@

@@TABLE@@
void @_LOWER:Name_@_PI_@_Timers_@(void)
{
 // There shoud be no timers in GUI functions
 // However the template may be modified to support them and do specific
 // action upon timer expiration (e.g. periodic check that the GUI queue
 // is still alive).
}
@@END_TABLE@@
