---------------------------------------------------
-- AADL2.2
-- TASTE type concurrencyview
-- 
-- generated code: do not edit
---------------------------------------------------

PROPERTY SET AI IS
  Root_System : AADLSTRING
    APPLIES TO(SYSTEM IMPLEMENTATION);
  Disabled_Processing_Tools : LIST OF AADLSTRING
    APPLIES TO(SYSTEM IMPLEMENTATION);
END AI;


PACKAGE concurrencyview::CV
PUBLIC
WITH AI;
WITH AIR::portpooling;
WITH DataView;
WITH TSP::DataView;
WITH Arinc653;
WITH ocarina_processors_leon;
WITH ocarina_processors_x86;
WITH deploymentview::DV::Platform;
WITH deploymentview::DV::Payload;

PROCESSOR Platform_leon_rtems_posix_cv
EXTENDS ocarina_processors_leon::leon
END Platform_leon_rtems_posix_cv;

PROCESSOR IMPLEMENTATION Platform_leon_rtems_posix_cv.final
EXTENDS ocarina_processors_leon::leon.rtems_posix
SUBCOMPONENTS
  Partition0_VP : VIRTUAL PROCESSOR deploymentview::DV::Platform::Partition0_VP.others;
  Partition1_VP : VIRTUAL PROCESSOR deploymentview::DV::Platform::Partition1_VP.others;
PROPERTIES
  SCHEDULING_PROTOCOL => (POSIX_1003_Highest_Priority_First_Protocol) APPLIES TO Partition0_VP;
  SCHEDULING_PROTOCOL => (POSIX_1003_Highest_Priority_First_Protocol) APPLIES TO Partition1_VP;
  ARINC653::DAL => LEVEL_A APPLIES TO Partition0_VP;
  ARINC653::DAL => LEVEL_A APPLIES TO Partition1_VP;
END Platform_leon_rtems_posix_cv.final;

PROCESSOR Payload_x86_linux32_cv
EXTENDS ocarina_processors_x86::x86
END Payload_x86_linux32_cv;

PROCESSOR IMPLEMENTATION Payload_x86_linux32_cv.final
EXTENDS ocarina_processors_x86::x86.linux32
END Payload_x86_linux32_cv.final;

PROCESS Partition0
EXTENDS deploymentview::DV::Platform::Partition0
END Partition0;

PROCESS IMPLEMENTATION Partition0.final
SUBCOMPONENTS
  AOCS_readSensors : THREAD AOCS_readSensors.others;
  AOCS_updateActuators : THREAD AOCS_updateActuators.others;
  AOCS_pi_readSensors : SUBPROGRAM AOCS_pi_readSensors.final;
  AOCS_pi_updateActuators : SUBPROGRAM AOCS_pi_updateActuators.final;
END Partition0.final;

PROCESS Partition1
EXTENDS deploymentview::DV::Platform::Partition1
FEATURES
  OUTPORT_TM_TC_receiveTC_Payload2_receiveP2_TC : OUT EVENT PORT ;
  OUTPORT_TM_TC_sendTM_Payload2_receiveP2_TC : OUT EVENT PORT ;
  OUTPORT_TM_TC_receiveP1_TM_Payload2_receiveP2_TC : OUT EVENT PORT ;
  OUTPORT_TM_TC_receiveP2_TM_Payload2_receiveP2_TC : OUT EVENT PORT ;
  OUTPORT_TM_TC_receiveTC_Payload1_receiveP1_TC : OUT EVENT DATA PORT TSP::DataView::MyEnum;
  OUTPORT_TM_TC_sendTM_Payload1_receiveP1_TC : OUT EVENT DATA PORT TSP::DataView::MyEnum;
  OUTPORT_TM_TC_receiveP1_TM_Payload1_receiveP1_TC : OUT EVENT DATA PORT TSP::DataView::MyEnum;
  OUTPORT_TM_TC_receiveP2_TM_Payload1_receiveP1_TC : OUT EVENT DATA PORT TSP::DataView::MyEnum;
  INPORT_TM_TC_receiveP1_TM_Payload1_receiveP1_TC : IN EVENT DATA PORT TSP::DataView::MyInteger;
  INPORT_TM_TC_receiveP2_TM_Payload2_receiveP2_TC : IN EVENT DATA PORT TSP::DataView::MyInteger;
END Partition1;

PROCESS IMPLEMENTATION Partition1.final
SUBCOMPONENTS
  TM_TC_receiveTC : THREAD TM_TC_receiveTC.others;
  TM_TC_sendTM : THREAD TM_TC_sendTM.others;
  TM_TC_receiveP1_TM : THREAD TM_TC_receiveP1_TM.others;
  TM_TC_receiveP2_TM : THREAD TM_TC_receiveP2_TM.others;
  TM_TC_pi_receiveTC : SUBPROGRAM TM_TC_pi_receiveTC.final;
  TM_TC_pi_sendTM : SUBPROGRAM TM_TC_pi_sendTM.final;
  TM_TC_pi_receiveP1_TM : SUBPROGRAM TM_TC_pi_receiveP1_TM.final;
  TM_TC_pi_receiveP2_TM : SUBPROGRAM TM_TC_pi_receiveP2_TM.final;
  port_poller : THREAD AIR::portpooling::port_poller.i;
CONNECTIONS
  PORT TM_TC_receiveTC.OUTPORT_TM_TC_receiveTC_Payload1_receiveP1_TC -> OUTPORT_TM_TC_receiveTC_Payload1_receiveP1_TC;
  PORT TM_TC_sendTM.OUTPORT_TM_TC_sendTM_Payload1_receiveP1_TC -> OUTPORT_TM_TC_sendTM_Payload1_receiveP1_TC;
  PORT TM_TC_receiveP1_TM.OUTPORT_TM_TC_receiveP1_TM_Payload1_receiveP1_TC -> OUTPORT_TM_TC_receiveP1_TM_Payload1_receiveP1_TC;
  PORT TM_TC_receiveP2_TM.OUTPORT_TM_TC_receiveP2_TM_Payload1_receiveP1_TC -> OUTPORT_TM_TC_receiveP2_TM_Payload1_receiveP1_TC;
  PORT TM_TC_receiveTC.OUTPORT_TM_TC_receiveTC_Payload2_receiveP2_TC -> OUTPORT_TM_TC_receiveTC_Payload2_receiveP2_TC;
  PORT TM_TC_sendTM.OUTPORT_TM_TC_sendTM_Payload2_receiveP2_TC -> OUTPORT_TM_TC_sendTM_Payload2_receiveP2_TC;
  PORT TM_TC_receiveP1_TM.OUTPORT_TM_TC_receiveP1_TM_Payload2_receiveP2_TC -> OUTPORT_TM_TC_receiveP1_TM_Payload2_receiveP2_TC;
  PORT TM_TC_receiveP2_TM.OUTPORT_TM_TC_receiveP2_TM_Payload2_receiveP2_TC -> OUTPORT_TM_TC_receiveP2_TM_Payload2_receiveP2_TC;
  PORT INPORT_TM_TC_receiveP1_TM_Payload1_receiveP1_TC -> TM_TC_receiveP1_TM.INPORT_TM_TC_receiveP1_TM_Payload1_receiveP1_TC;
  PORT INPORT_TM_TC_receiveP2_TM_Payload2_receiveP2_TC -> TM_TC_receiveP2_TM.INPORT_TM_TC_receiveP2_TM_Payload2_receiveP2_TC;
END Partition1.final;

PROCESS x86_partition
EXTENDS deploymentview::DV::Payload::x86_partition
FEATURES
  OUTPORT_Payload1_receiveP1_TC_TM_TC_receiveP1_TM : OUT EVENT DATA PORT TSP::DataView::MyInteger;
  OUTPORT_Payload2_receiveP2_TC_TM_TC_receiveP2_TM : OUT EVENT DATA PORT TSP::DataView::MyInteger;
  INPORT_Payload2_receiveP2_TC_TM_TC_receiveTC : IN EVENT PORT ;
  INPORT_Payload2_receiveP2_TC_TM_TC_sendTM : IN EVENT PORT ;
  INPORT_Payload2_receiveP2_TC_TM_TC_receiveP1_TM : IN EVENT PORT ;
  INPORT_Payload2_receiveP2_TC_TM_TC_receiveP2_TM : IN EVENT PORT ;
  INPORT_Payload1_receiveP1_TC_TM_TC_receiveTC : IN EVENT DATA PORT TSP::DataView::MyEnum;
  INPORT_Payload1_receiveP1_TC_TM_TC_sendTM : IN EVENT DATA PORT TSP::DataView::MyEnum;
  INPORT_Payload1_receiveP1_TC_TM_TC_receiveP1_TM : IN EVENT DATA PORT TSP::DataView::MyEnum;
  INPORT_Payload1_receiveP1_TC_TM_TC_receiveP2_TM : IN EVENT DATA PORT TSP::DataView::MyEnum;
END x86_partition;

PROCESS IMPLEMENTATION x86_partition.final
SUBCOMPONENTS
  Payload1_receiveP1_TC : THREAD Payload1_receiveP1_TC.others;
  Payload2_receiveP2_TC : THREAD Payload2_receiveP2_TC.others;
  Payload1_pi_receiveP1_TC : SUBPROGRAM Payload1_pi_receiveP1_TC.final;
  Payload2_pi_receiveP2_TC : SUBPROGRAM Payload2_pi_receiveP2_TC.final;
  port_poller : THREAD AIR::portpooling::port_poller.i;
CONNECTIONS
  PORT Payload1_receiveP1_TC.OUTPORT_Payload1_receiveP1_TC_TM_TC_receiveP1_TM -> OUTPORT_Payload1_receiveP1_TC_TM_TC_receiveP1_TM;
  PORT Payload2_receiveP2_TC.OUTPORT_Payload2_receiveP2_TC_TM_TC_receiveP2_TM -> OUTPORT_Payload2_receiveP2_TC_TM_TC_receiveP2_TM;
  PORT INPORT_Payload1_receiveP1_TC_TM_TC_receiveTC -> Payload1_receiveP1_TC.INPORT_Payload1_receiveP1_TC_TM_TC_receiveTC;
  PORT INPORT_Payload1_receiveP1_TC_TM_TC_sendTM -> Payload1_receiveP1_TC.INPORT_Payload1_receiveP1_TC_TM_TC_sendTM;
  PORT INPORT_Payload1_receiveP1_TC_TM_TC_receiveP1_TM -> Payload1_receiveP1_TC.INPORT_Payload1_receiveP1_TC_TM_TC_receiveP1_TM;
  PORT INPORT_Payload1_receiveP1_TC_TM_TC_receiveP2_TM -> Payload1_receiveP1_TC.INPORT_Payload1_receiveP1_TC_TM_TC_receiveP2_TM;
  PORT INPORT_Payload2_receiveP2_TC_TM_TC_receiveTC -> Payload2_receiveP2_TC.INPORT_Payload2_receiveP2_TC_TM_TC_receiveTC;
  PORT INPORT_Payload2_receiveP2_TC_TM_TC_sendTM -> Payload2_receiveP2_TC.INPORT_Payload2_receiveP2_TC_TM_TC_sendTM;
  PORT INPORT_Payload2_receiveP2_TC_TM_TC_receiveP1_TM -> Payload2_receiveP2_TC.INPORT_Payload2_receiveP2_TC_TM_TC_receiveP1_TM;
  PORT INPORT_Payload2_receiveP2_TC_TM_TC_receiveP2_TM -> Payload2_receiveP2_TC.INPORT_Payload2_receiveP2_TC_TM_TC_receiveP2_TM;
END x86_partition.final;

SYSTEM deploymentview
END deploymentview;

SYSTEM IMPLEMENTATION deploymentview.final
SUBCOMPONENTS
  serial_generic_cv : BUS ocarina_buses::serial.generic;
  Platform_generic_serial_raw_cv : DEVICE deploymentview::DV::Platform::generic_serial_raw.others;
  Payload_generic_serial_raw_cv : DEVICE deploymentview::DV::Payload::generic_serial_raw.others;
  Partition0 : PROCESS Partition0.final;
  Partition1 : PROCESS Partition1.final;
  x86_partition : PROCESS x86_partition.final;
  Platform_leon_rtems_posix_cv : PROCESSOR Platform_leon_rtems_posix_cv.final;
  Payload_x86_linux32_cv : PROCESSOR Payload_x86_linux32_cv.final;
  Platform_main_memory : MEMORY deploymentview::DV::Platform::main_memory.others;
CONNECTIONS
  Partition1_INPORT_TM_TC_receiveP1_TM_Payload1_receiveP1_TC : PORT x86_partition.OUTPORT_Payload1_receiveP1_TC_TM_TC_receiveP1_TM -> Partition1.INPORT_TM_TC_receiveP1_TM_Payload1_receiveP1_TC;
  Partition1_INPORT_TM_TC_receiveP2_TM_Payload2_receiveP2_TC : PORT x86_partition.OUTPORT_Payload2_receiveP2_TC_TM_TC_receiveP2_TM -> Partition1.INPORT_TM_TC_receiveP2_TM_Payload2_receiveP2_TC;
  x86_partition_INPORT_Payload1_receiveP1_TC_TM_TC_receiveTC : PORT Partition1.OUTPORT_TM_TC_receiveTC_Payload1_receiveP1_TC -> x86_partition.INPORT_Payload1_receiveP1_TC_TM_TC_receiveTC;
  x86_partition_INPORT_Payload1_receiveP1_TC_TM_TC_sendTM : PORT Partition1.OUTPORT_TM_TC_sendTM_Payload1_receiveP1_TC -> x86_partition.INPORT_Payload1_receiveP1_TC_TM_TC_sendTM;
  x86_partition_INPORT_Payload1_receiveP1_TC_TM_TC_receiveP1_TM : PORT Partition1.OUTPORT_TM_TC_receiveP1_TM_Payload1_receiveP1_TC -> x86_partition.INPORT_Payload1_receiveP1_TC_TM_TC_receiveP1_TM;
  x86_partition_INPORT_Payload1_receiveP1_TC_TM_TC_receiveP2_TM : PORT Partition1.OUTPORT_TM_TC_receiveP2_TM_Payload1_receiveP1_TC -> x86_partition.INPORT_Payload1_receiveP1_TC_TM_TC_receiveP2_TM;
  x86_partition_INPORT_Payload2_receiveP2_TC_TM_TC_receiveTC : PORT Partition1.OUTPORT_TM_TC_receiveTC_Payload2_receiveP2_TC -> x86_partition.INPORT_Payload2_receiveP2_TC_TM_TC_receiveTC;
  x86_partition_INPORT_Payload2_receiveP2_TC_TM_TC_sendTM : PORT Partition1.OUTPORT_TM_TC_sendTM_Payload2_receiveP2_TC -> x86_partition.INPORT_Payload2_receiveP2_TC_TM_TC_sendTM;
  x86_partition_INPORT_Payload2_receiveP2_TC_TM_TC_receiveP1_TM : PORT Partition1.OUTPORT_TM_TC_receiveP1_TM_Payload2_receiveP2_TC -> x86_partition.INPORT_Payload2_receiveP2_TC_TM_TC_receiveP1_TM;
  x86_partition_INPORT_Payload2_receiveP2_TC_TM_TC_receiveP2_TM : PORT Partition1.OUTPORT_TM_TC_receiveP2_TM_Payload2_receiveP2_TC -> x86_partition.INPORT_Payload2_receiveP2_TC_TM_TC_receiveP2_TM;
  serial_generic_cv_Platform_generic_serial_raw_cv : BUS ACCESS serial_generic_cv -> Platform_generic_serial_raw_cv.link;
  serial_generic_cv_Payload_generic_serial_raw_cv : BUS ACCESS serial_generic_cv -> Payload_generic_serial_raw_cv.link;
PROPERTIES
  AI::ROOT_SYSTEM => "generated";
  ACTUAL_PROCESSOR_BINDING => (REFERENCE(Platform_leon_rtems_posix_cv.Partition0_VP)) APPLIES TO Partition0;
  ACTUAL_PROCESSOR_BINDING => (REFERENCE(Platform_leon_rtems_posix_cv.Partition1_VP)) APPLIES TO Partition1;
  ACTUAL_PROCESSOR_BINDING => (REFERENCE(Payload_x86_linux32_cv)) APPLIES TO x86_partition;
  ACTUAL_MEMORY_BINDING => (Reference(Platform_main_memory.Partition0_Segment)) APPLIES TO Partition0;
  ACTUAL_MEMORY_BINDING => (Reference(Platform_main_memory.Partition1_Segment)) APPLIES TO Partition1;
  ARINC653::MODULE_MAJOR_FRAME => 100 ms APPLIES TO Platform_leon_rtems_posix_cv;
  ARINC653::MODULE_SCHEDULE => (
    [PARTITION=>Reference(Platform_leon_rtems_posix_cv.Partition0_VP);Duration=>50 ms;PERIODIC_PROCESSING_START=>FALSE;],
    [PARTITION=>Reference(Platform_leon_rtems_posix_cv.Partition1_VP);Duration=>50 ms;PERIODIC_PROCESSING_START=>FALSE;]
  ) APPLIES TO Platform_leon_rtems_posix_cv;
  ACTUAL_CONNECTION_BINDING => (REFERENCE(serial_generic_cv)) APPLIES TO x86_partition_receiveP1_TC_vt_TM_TC_receiveTC;
  ACTUAL_CONNECTION_BINDING => (REFERENCE(serial_generic_cv)) APPLIES TO x86_partition_receiveP1_TC_vt_TM_TC_sendTM;
  ACTUAL_CONNECTION_BINDING => (REFERENCE(serial_generic_cv)) APPLIES TO x86_partition_receiveP1_TC_vt_TM_TC_receiveP1_TM;
  ACTUAL_CONNECTION_BINDING => (REFERENCE(serial_generic_cv)) APPLIES TO x86_partition_receiveP1_TC_vt_TM_TC_receiveP2_TM;
  ACTUAL_CONNECTION_BINDING => (REFERENCE(serial_generic_cv)) APPLIES TO x86_partition_receiveP2_TC_vt_TM_TC_receiveTC;
  ACTUAL_CONNECTION_BINDING => (REFERENCE(serial_generic_cv)) APPLIES TO x86_partition_receiveP2_TC_vt_TM_TC_sendTM;
  ACTUAL_CONNECTION_BINDING => (REFERENCE(serial_generic_cv)) APPLIES TO x86_partition_receiveP2_TC_vt_TM_TC_receiveP1_TM;
  ACTUAL_CONNECTION_BINDING => (REFERENCE(serial_generic_cv)) APPLIES TO x86_partition_receiveP2_TC_vt_TM_TC_receiveP2_TM;
  ACTUAL_CONNECTION_BINDING => (REFERENCE(serial_generic_cv)) APPLIES TO Partition1_receiveP1_TM_vt_Payload1_receiveP1_TC;
  ACTUAL_CONNECTION_BINDING => (REFERENCE(serial_generic_cv)) APPLIES TO Partition1_receiveP2_TM_vt_Payload2_receiveP2_TC;
  ACTUAL_PROCESSOR_BINDING => (REFERENCE(Platform_leon_rtems_posix_cv)) APPLIES TO Platform_generic_serial_raw_cv;
  ACTUAL_PROCESSOR_BINDING => (REFERENCE(Payload_x86_linux32_cv)) APPLIES TO Payload_generic_serial_raw_cv;
  PERIOD => 50 ms APPLIES TO Partition1.port_poller;
END deploymentview.final;

THREAD AOCS_readSensors
END AOCS_readSensors;

THREAD IMPLEMENTATION AOCS_readSensors.others
CALLS
  MyCalls : { 
    MyCall : SUBPROGRAM AOCS_pi_readSensors;
  };
PROPERTIES
  DISPATCH_PROTOCOL => Periodic;
  PERIOD => 100 ms;
  DEADLINE => 100 ms;
  COMPUTE_EXECUTION_TIME => 0 ms..2 ms;
ANNEX behavior_specification {**
**};
END AOCS_readSensors.others;

THREAD AOCS_updateActuators
END AOCS_updateActuators;

THREAD IMPLEMENTATION AOCS_updateActuators.others
CALLS
  MyCalls : { 
    MyCall : SUBPROGRAM AOCS_pi_updateActuators;
  };
PROPERTIES
  DISPATCH_PROTOCOL => Periodic;
  PERIOD => 100 ms;
  DEADLINE => 100 ms;
  COMPUTE_EXECUTION_TIME => 0 ms..5 ms;
ANNEX behavior_specification {**
**};
END AOCS_updateActuators.others;

THREAD TM_TC_receiveTC
FEATURES
  OUTPORT_TM_TC_receiveTC_Payload2_receiveP2_TC : OUT EVENT PORT ;
  OUTPORT_TM_TC_receiveTC_Payload1_receiveP1_TC : OUT EVENT DATA PORT TSP::DataView::MyEnum;
END TM_TC_receiveTC;

THREAD IMPLEMENTATION TM_TC_receiveTC.others
CALLS
  MyCalls : { 
    MyCall : SUBPROGRAM TM_TC_pi_receiveTC;
  };
CONNECTIONS
  MyCall_OUTPORT_TM_TC_receiveTC_Payload1_receiveP1_TC : PARAMETER MyCall.OUTPORT_TM_TC_receiveTC_Payload1_receiveP1_TC -> OUTPORT_TM_TC_receiveTC_Payload1_receiveP1_TC;
PROPERTIES
  DISPATCH_PROTOCOL => Periodic;
  PERIOD => 200 ms;
  DEADLINE => 200 ms;
  COMPUTE_EXECUTION_TIME => 0 ms..10 ms;
ANNEX behavior_specification {**
**};
END TM_TC_receiveTC.others;

THREAD TM_TC_sendTM
FEATURES
  OUTPORT_TM_TC_sendTM_Payload2_receiveP2_TC : OUT EVENT PORT ;
  OUTPORT_TM_TC_sendTM_Payload1_receiveP1_TC : OUT EVENT DATA PORT TSP::DataView::MyEnum;
END TM_TC_sendTM;

THREAD IMPLEMENTATION TM_TC_sendTM.others
CALLS
  MyCalls : { 
    MyCall : SUBPROGRAM TM_TC_pi_sendTM;
  };
CONNECTIONS
  MyCall_OUTPORT_TM_TC_sendTM_Payload1_receiveP1_TC : PARAMETER MyCall.OUTPORT_TM_TC_sendTM_Payload1_receiveP1_TC -> OUTPORT_TM_TC_sendTM_Payload1_receiveP1_TC;
PROPERTIES
  DISPATCH_PROTOCOL => Periodic;
  PERIOD => 200 ms;
  DEADLINE => 200 ms;
  COMPUTE_EXECUTION_TIME => 0 ms..20 ms;
ANNEX behavior_specification {**
**};
END TM_TC_sendTM.others;

THREAD TM_TC_receiveP1_TM
FEATURES
  INPORT_TM_TC_receiveP1_TM_Payload1_receiveP1_TC : IN EVENT DATA PORT TSP::DataView::MyInteger;
  OUTPORT_TM_TC_receiveP1_TM_Payload2_receiveP2_TC : OUT EVENT PORT ;
  OUTPORT_TM_TC_receiveP1_TM_Payload1_receiveP1_TC : OUT EVENT DATA PORT TSP::DataView::MyEnum;
END TM_TC_receiveP1_TM;

THREAD IMPLEMENTATION TM_TC_receiveP1_TM.others
CALLS
  MyCalls : { 
    MyCall : SUBPROGRAM TM_TC_pi_receiveP1_TM;
  };
CONNECTIONS
  MyCall_INPORT_TM_TC_receiveP1_TM_Payload1_receiveP1_TC : PARAMETER INPORT_TM_TC_receiveP1_TM_Payload1_receiveP1_TC -> MyCall.INPORT_TM_TC_receiveP1_TM_Payload1_receiveP1_TC;
  MyCall_OUTPORT_TM_TC_receiveP1_TM_Payload1_receiveP1_TC : PARAMETER MyCall.OUTPORT_TM_TC_receiveP1_TM_Payload1_receiveP1_TC -> OUTPORT_TM_TC_receiveP1_TM_Payload1_receiveP1_TC;
PROPERTIES
  DISPATCH_PROTOCOL => Sporadic;
  PERIOD => 300 ms;
  DEADLINE => 300 ms;
  COMPUTE_EXECUTION_TIME => 0 ms..5 ms;
ANNEX behavior_specification {**
**};
END TM_TC_receiveP1_TM.others;

THREAD TM_TC_receiveP2_TM
FEATURES
  INPORT_TM_TC_receiveP2_TM_Payload2_receiveP2_TC : IN EVENT DATA PORT TSP::DataView::MyInteger;
  OUTPORT_TM_TC_receiveP2_TM_Payload2_receiveP2_TC : OUT EVENT PORT ;
  OUTPORT_TM_TC_receiveP2_TM_Payload1_receiveP1_TC : OUT EVENT DATA PORT TSP::DataView::MyEnum;
END TM_TC_receiveP2_TM;

THREAD IMPLEMENTATION TM_TC_receiveP2_TM.others
CALLS
  MyCalls : { 
    MyCall : SUBPROGRAM TM_TC_pi_receiveP2_TM;
  };
CONNECTIONS
  MyCall_INPORT_TM_TC_receiveP2_TM_Payload2_receiveP2_TC : PARAMETER INPORT_TM_TC_receiveP2_TM_Payload2_receiveP2_TC -> MyCall.INPORT_TM_TC_receiveP2_TM_Payload2_receiveP2_TC;
  MyCall_OUTPORT_TM_TC_receiveP2_TM_Payload1_receiveP1_TC : PARAMETER MyCall.OUTPORT_TM_TC_receiveP2_TM_Payload1_receiveP1_TC -> OUTPORT_TM_TC_receiveP2_TM_Payload1_receiveP1_TC;
PROPERTIES
  DISPATCH_PROTOCOL => Sporadic;
  PERIOD => 400 ms;
  DEADLINE => 400 ms;
  COMPUTE_EXECUTION_TIME => 0 ms..10 ms;
ANNEX behavior_specification {**
**};
END TM_TC_receiveP2_TM.others;

THREAD Payload1_receiveP1_TC
FEATURES
  INPORT_Payload1_receiveP1_TC_TM_TC_receiveTC : IN EVENT DATA PORT TSP::DataView::MyEnum;
  INPORT_Payload1_receiveP1_TC_TM_TC_sendTM : IN EVENT DATA PORT TSP::DataView::MyEnum;
  INPORT_Payload1_receiveP1_TC_TM_TC_receiveP1_TM : IN EVENT DATA PORT TSP::DataView::MyEnum;
  INPORT_Payload1_receiveP1_TC_TM_TC_receiveP2_TM : IN EVENT DATA PORT TSP::DataView::MyEnum;
  OUTPORT_Payload1_receiveP1_TC_TM_TC_receiveP1_TM : OUT EVENT DATA PORT TSP::DataView::MyInteger;
END Payload1_receiveP1_TC;

THREAD IMPLEMENTATION Payload1_receiveP1_TC.others
CALLS
  MyCalls : { 
    MyCall : SUBPROGRAM Payload1_pi_receiveP1_TC;
  };
CONNECTIONS
  MyCall_INPORT_Payload1_receiveP1_TC_TM_TC_receiveTC : PARAMETER INPORT_Payload1_receiveP1_TC_TM_TC_receiveTC -> MyCall.INPORT_Payload1_receiveP1_TC_TM_TC_receiveTC;
  MyCall_INPORT_Payload1_receiveP1_TC_TM_TC_sendTM : PARAMETER INPORT_Payload1_receiveP1_TC_TM_TC_sendTM -> MyCall.INPORT_Payload1_receiveP1_TC_TM_TC_sendTM;
  MyCall_INPORT_Payload1_receiveP1_TC_TM_TC_receiveP1_TM : PARAMETER INPORT_Payload1_receiveP1_TC_TM_TC_receiveP1_TM -> MyCall.INPORT_Payload1_receiveP1_TC_TM_TC_receiveP1_TM;
  MyCall_INPORT_Payload1_receiveP1_TC_TM_TC_receiveP2_TM : PARAMETER INPORT_Payload1_receiveP1_TC_TM_TC_receiveP2_TM -> MyCall.INPORT_Payload1_receiveP1_TC_TM_TC_receiveP2_TM;
  MyCall_OUTPORT_Payload1_receiveP1_TC_TM_TC_receiveP1_TM : PARAMETER MyCall.OUTPORT_Payload1_receiveP1_TC_TM_TC_receiveP1_TM -> OUTPORT_Payload1_receiveP1_TC_TM_TC_receiveP1_TM;
PROPERTIES
  DISPATCH_PROTOCOL => Sporadic;
  PERIOD => 200 ms;
  DEADLINE => 200 ms;
  COMPUTE_EXECUTION_TIME => 0 ms..2 ms;
ANNEX behavior_specification {**
**};
END Payload1_receiveP1_TC.others;

THREAD Payload2_receiveP2_TC
FEATURES
  INPORT_Payload2_receiveP2_TC_TM_TC_receiveTC : IN EVENT PORT ;
  INPORT_Payload2_receiveP2_TC_TM_TC_sendTM : IN EVENT PORT ;
  INPORT_Payload2_receiveP2_TC_TM_TC_receiveP1_TM : IN EVENT PORT ;
  INPORT_Payload2_receiveP2_TC_TM_TC_receiveP2_TM : IN EVENT PORT ;
  OUTPORT_Payload2_receiveP2_TC_TM_TC_receiveP2_TM : OUT EVENT DATA PORT TSP::DataView::MyInteger;
END Payload2_receiveP2_TC;

THREAD IMPLEMENTATION Payload2_receiveP2_TC.others
CALLS
  MyCalls : { 
    MyCall : SUBPROGRAM Payload2_pi_receiveP2_TC;
  };
CONNECTIONS
  MyCall_OUTPORT_Payload2_receiveP2_TC_TM_TC_receiveP2_TM : PARAMETER MyCall.OUTPORT_Payload2_receiveP2_TC_TM_TC_receiveP2_TM -> OUTPORT_Payload2_receiveP2_TC_TM_TC_receiveP2_TM;
PROPERTIES
  DISPATCH_PROTOCOL => Sporadic;
  PERIOD => 300 ms;
  DEADLINE => 300 ms;
  COMPUTE_EXECUTION_TIME => 0 ms..5 ms;
ANNEX behavior_specification {**
**};
END Payload2_receiveP2_TC.others;

SUBPROGRAM AOCS_pi_readSensors
PROPERTIES
  COMPUTE_EXECUTION_TIME => 2 ms..2 ms;
  SOURCE_LANGUAGE => (C);
  SOURCE_NAME => "AOCS_pi_readSensors";
  SOURCE_TEXT => ("AOCS/AOCS.c");
END AOCS_pi_readSensors;

SUBPROGRAM IMPLEMENTATION AOCS_pi_readSensors.final
END AOCS_pi_readSensors.final;

SUBPROGRAM AOCS_pi_updateActuators
PROPERTIES
  COMPUTE_EXECUTION_TIME => 5 ms..5 ms;
  SOURCE_LANGUAGE => (C);
  SOURCE_NAME => "AOCS_pi_updateActuators";
  SOURCE_TEXT => ("AOCS/AOCS.c");
END AOCS_pi_updateActuators;

SUBPROGRAM IMPLEMENTATION AOCS_pi_updateActuators.final
END AOCS_pi_updateActuators.final;

SUBPROGRAM TM_TC_pi_receiveTC
FEATURES
  OUTPORT_TM_TC_receiveTC_Payload1_receiveP1_TC : OUT PARAMETER TSP::DataView::MyEnum;
PROPERTIES
  COMPUTE_EXECUTION_TIME => 10 ms..10 ms;
  SOURCE_LANGUAGE => (C);
  SOURCE_NAME => "TM_TC_pi_receiveTC";
  SOURCE_TEXT => ("TM_TC/TM_TC.c");
END TM_TC_pi_receiveTC;

SUBPROGRAM IMPLEMENTATION TM_TC_pi_receiveTC.final
END TM_TC_pi_receiveTC.final;

SUBPROGRAM TM_TC_pi_sendTM
FEATURES
  OUTPORT_TM_TC_sendTM_Payload1_receiveP1_TC : OUT PARAMETER TSP::DataView::MyEnum;
PROPERTIES
  COMPUTE_EXECUTION_TIME => 20 ms..20 ms;
  SOURCE_LANGUAGE => (C);
  SOURCE_NAME => "TM_TC_pi_sendTM";
  SOURCE_TEXT => ("TM_TC/TM_TC.c");
END TM_TC_pi_sendTM;

SUBPROGRAM IMPLEMENTATION TM_TC_pi_sendTM.final
END TM_TC_pi_sendTM.final;

SUBPROGRAM TM_TC_pi_receiveP1_TM
FEATURES
  INPORT_TM_TC_receiveP1_TM_Payload1_receiveP1_TC : IN PARAMETER TSP::DataView::MyInteger;
  OUTPORT_TM_TC_receiveP1_TM_Payload1_receiveP1_TC : OUT PARAMETER TSP::DataView::MyEnum;
PROPERTIES
  COMPUTE_EXECUTION_TIME => 5 ms..5 ms;
  SOURCE_LANGUAGE => (C);
  SOURCE_NAME => "TM_TC_pi_receiveP1_TM";
  SOURCE_TEXT => ("TM_TC/TM_TC.c");
END TM_TC_pi_receiveP1_TM;

SUBPROGRAM IMPLEMENTATION TM_TC_pi_receiveP1_TM.final
END TM_TC_pi_receiveP1_TM.final;

SUBPROGRAM TM_TC_pi_receiveP2_TM
FEATURES
  INPORT_TM_TC_receiveP2_TM_Payload2_receiveP2_TC : IN PARAMETER TSP::DataView::MyInteger;
  OUTPORT_TM_TC_receiveP2_TM_Payload1_receiveP1_TC : OUT PARAMETER TSP::DataView::MyEnum;
PROPERTIES
  COMPUTE_EXECUTION_TIME => 10 ms..10 ms;
  SOURCE_LANGUAGE => (C);
  SOURCE_NAME => "TM_TC_pi_receiveP2_TM";
  SOURCE_TEXT => ("TM_TC/TM_TC.c");
END TM_TC_pi_receiveP2_TM;

SUBPROGRAM IMPLEMENTATION TM_TC_pi_receiveP2_TM.final
END TM_TC_pi_receiveP2_TM.final;

SUBPROGRAM Payload1_pi_receiveP1_TC
FEATURES
  INPORT_Payload1_receiveP1_TC_TM_TC_receiveTC : IN PARAMETER TSP::DataView::MyEnum;
  INPORT_Payload1_receiveP1_TC_TM_TC_sendTM : IN PARAMETER TSP::DataView::MyEnum;
  INPORT_Payload1_receiveP1_TC_TM_TC_receiveP1_TM : IN PARAMETER TSP::DataView::MyEnum;
  INPORT_Payload1_receiveP1_TC_TM_TC_receiveP2_TM : IN PARAMETER TSP::DataView::MyEnum;
  OUTPORT_Payload1_receiveP1_TC_TM_TC_receiveP1_TM : OUT PARAMETER TSP::DataView::MyInteger;
PROPERTIES
  COMPUTE_EXECUTION_TIME => 2 ms..2 ms;
  SOURCE_LANGUAGE => (C);
  SOURCE_NAME => "Payload1_pi_receiveP1_TC";
  SOURCE_TEXT => ("Payload1/Payload1.c");
END Payload1_pi_receiveP1_TC;

SUBPROGRAM IMPLEMENTATION Payload1_pi_receiveP1_TC.final
END Payload1_pi_receiveP1_TC.final;

SUBPROGRAM Payload2_pi_receiveP2_TC
FEATURES
  OUTPORT_Payload2_receiveP2_TC_TM_TC_receiveP2_TM : OUT PARAMETER TSP::DataView::MyInteger;
PROPERTIES
  COMPUTE_EXECUTION_TIME => 5 ms..5 ms;
  SOURCE_LANGUAGE => (C);
  SOURCE_NAME => "Payload2_pi_receiveP2_TC";
  SOURCE_TEXT => ("Payload2/Payload2.c");
END Payload2_pi_receiveP2_TC;

SUBPROGRAM IMPLEMENTATION Payload2_pi_receiveP2_TC.final
END Payload2_pi_receiveP2_TC.final;

END concurrencyview::CV;




---------------------------------------------------
-- AADL2.1
-- TASTE type interfaceview
-- 
-- generated code: do not edit
---------------------------------------------------

PACKAGE interfaceview::IV::AOCS
PUBLIC

WITH Taste;
WITH DataView;
WITH TASTE_IV_Properties;
SUBPROGRAM PI_readSensors
END PI_readSensors;

SUBPROGRAM IMPLEMENTATION PI_readSensors.others
PROPERTIES
  Compute_Execution_Time => 0 ms .. 2 ms;
END PI_readSensors.others;

SUBPROGRAM PI_updateActuators
END PI_updateActuators;

SUBPROGRAM IMPLEMENTATION PI_updateActuators.others
PROPERTIES
  Compute_Execution_Time => 0 ms .. 5 ms;
END PI_updateActuators.others;

SUBPROGRAM PI_receiveAOCS_TC
FEATURES
  TC : IN PARAMETER DataView::MyEnum {
    Taste::encoding => NATIVE;
  };
PROPERTIES
  Taste::Associated_Queue_Size => 1;
END PI_receiveAOCS_TC;

SUBPROGRAM IMPLEMENTATION PI_receiveAOCS_TC.others
PROPERTIES
  Compute_Execution_Time => 0 ms .. 1 ms;
END PI_receiveAOCS_TC.others;

SUBPROGRAM PI_sendAOCS_TM
FEATURES
  TM : OUT PARAMETER DataView::MyInteger {
    Taste::encoding => NATIVE;
  };
PROPERTIES
  Taste::Associated_Queue_Size => 1;
END PI_sendAOCS_TM;

SUBPROGRAM IMPLEMENTATION PI_sendAOCS_TM.others
PROPERTIES
  Compute_Execution_Time => 0 ms .. 1 ms;
END PI_sendAOCS_TM.others;

SYSTEM AOCS
FEATURES
  PI_readSensors : PROVIDES SUBPROGRAM ACCESS interfaceview::IV::AOCS::PI_readSensors.others {
    Taste::coordinates => "96107 64316";
    Taste::RCMoperationKind => cyclic;
    Taste::RCMperiod => 100 ms;
    Taste::Deadline => 100 ms;
    Taste::InterfaceName => "readSensors";
  };
  PI_updateActuators : PROVIDES SUBPROGRAM ACCESS interfaceview::IV::AOCS::PI_updateActuators.others {
    Taste::coordinates => "96107 62117";
    Taste::RCMoperationKind => cyclic;
    Taste::RCMperiod => 100 ms;
    Taste::Deadline => 100 ms;
    Taste::InterfaceName => "updateActuators";
  };
  PI_receiveAOCS_TC : PROVIDES SUBPROGRAM ACCESS interfaceview::IV::AOCS::PI_receiveAOCS_TC.others {
    Taste::coordinates => "103247 74960";
    Taste::RCMoperationKind => unprotected;
    Taste::RCMperiod => 0 ms;
    Taste::Deadline => 0 ms;
    Taste::InterfaceName => "receiveAOCS_TC";
  };
  PI_sendAOCS_TM : PROVIDES SUBPROGRAM ACCESS interfaceview::IV::AOCS::PI_sendAOCS_TM.others {
    Taste::coordinates => "113808 74960";
    Taste::RCMoperationKind => unprotected;
    Taste::RCMperiod => 0 ms;
    Taste::Deadline => 0 ms;
    Taste::InterfaceName => "sendAOCS_TM";
  };
PROPERTIES
  Source_Language => (C);
  Taste::Active_Interfaces => any;
END AOCS;

SYSTEM IMPLEMENTATION AOCS.others
END AOCS.others;

END interfaceview::IV::AOCS;

PACKAGE interfaceview::IV::TM_TC
PUBLIC

WITH interfaceview::IV::AOCS;
WITH interfaceview::IV::Payload1;
WITH interfaceview::IV::Payload2;
WITH Taste;
WITH DataView;
WITH TASTE_IV_Properties;
SUBPROGRAM PI_receiveTC
END PI_receiveTC;

SUBPROGRAM IMPLEMENTATION PI_receiveTC.others
PROPERTIES
  Compute_Execution_Time => 0 ms .. 10 ms;
END PI_receiveTC.others;

SUBPROGRAM PI_sendTM
END PI_sendTM;

SUBPROGRAM IMPLEMENTATION PI_sendTM.others
PROPERTIES
  Compute_Execution_Time => 0 ms .. 20 ms;
END PI_sendTM.others;

SUBPROGRAM PI_receiveP1_TM
FEATURES
  TM : IN PARAMETER DataView::MyInteger {
    Taste::encoding => NATIVE;
  };
PROPERTIES
  Taste::Associated_Queue_Size => 1;
END PI_receiveP1_TM;

SUBPROGRAM IMPLEMENTATION PI_receiveP1_TM.others
PROPERTIES
  Compute_Execution_Time => 0 ms .. 5 ms;
END PI_receiveP1_TM.others;

SUBPROGRAM PI_receiveP2_TM
FEATURES
  TM : IN PARAMETER DataView::MyInteger {
    Taste::encoding => NATIVE;
  };
PROPERTIES
  Taste::Associated_Queue_Size => 1;
END PI_receiveP2_TM;

SUBPROGRAM IMPLEMENTATION PI_receiveP2_TM.others
PROPERTIES
  Compute_Execution_Time => 0 ms .. 10 ms;
END PI_receiveP2_TM.others;

SUBPROGRAM RI_receiveAOCS_TC
FEATURES
  TC : IN PARAMETER DataView::MyEnum {
    Taste::encoding => NATIVE;
  };
END RI_receiveAOCS_TC;

SUBPROGRAM IMPLEMENTATION RI_receiveAOCS_TC.others
END RI_receiveAOCS_TC.others;

SUBPROGRAM RI_sendAOCS_TM
FEATURES
  TM : OUT PARAMETER DataView::MyInteger {
    Taste::encoding => NATIVE;
  };
END RI_sendAOCS_TM;

SUBPROGRAM IMPLEMENTATION RI_sendAOCS_TM.others
END RI_sendAOCS_TM.others;

SUBPROGRAM RI_receiveP1_TC
FEATURES
  TC : IN PARAMETER DataView::MyEnum {
    Taste::encoding => NATIVE;
  };
END RI_receiveP1_TC;

SUBPROGRAM IMPLEMENTATION RI_receiveP1_TC.others
END RI_receiveP1_TC.others;

SUBPROGRAM RI_receiveP2_TC
END RI_receiveP2_TC;

SUBPROGRAM IMPLEMENTATION RI_receiveP2_TC.others
END RI_receiveP2_TC.others;

SYSTEM TM_TC
FEATURES
  PI_receiveTC : PROVIDES SUBPROGRAM ACCESS interfaceview::IV::TM_TC::PI_receiveTC.others {
    Taste::coordinates => "95949 85321";
    Taste::RCMoperationKind => cyclic;
    Taste::RCMperiod => 200 ms;
    Taste::Deadline => 200 ms;
    Taste::InterfaceName => "receiveTC";
  };
  PI_sendTM : PROVIDES SUBPROGRAM ACCESS interfaceview::IV::TM_TC::PI_sendTM.others {
    Taste::coordinates => "95949 87313";
    Taste::RCMoperationKind => cyclic;
    Taste::RCMperiod => 200 ms;
    Taste::Deadline => 200 ms;
    Taste::InterfaceName => "sendTM";
  };
  PI_receiveP1_TM : PROVIDES SUBPROGRAM ACCESS interfaceview::IV::TM_TC::PI_receiveP1_TM.others {
    Taste::coordinates => "122619 86305";
    Taste::RCMoperationKind => sporadic;
    Taste::RCMperiod => 300 ms;
    Taste::Deadline => 300 ms;
    Taste::InterfaceName => "receiveP1_TM";
  };
  PI_receiveP2_TM : PROVIDES SUBPROGRAM ACCESS interfaceview::IV::TM_TC::PI_receiveP2_TM.others {
    Taste::coordinates => "122619 90445";
    Taste::RCMoperationKind => sporadic;
    Taste::RCMperiod => 400 ms;
    Taste::Deadline => 400 ms;
    Taste::InterfaceName => "receiveP2_TM";
  };
  RI_receiveAOCS_TC : REQUIRES SUBPROGRAM ACCESS interfaceview::IV::AOCS::PI_receiveAOCS_TC.others {
    Taste::coordinates => "101717 82165";
    Taste::RCMoperationKind => any;
    Taste::InterfaceName => "receiveAOCS_TC";
    Taste::labelInheritance => "true";
  };
  RI_sendAOCS_TM : REQUIRES SUBPROGRAM ACCESS interfaceview::IV::AOCS::PI_sendAOCS_TM.others {
    Taste::coordinates => "112276 82165";
    Taste::RCMoperationKind => any;
    Taste::InterfaceName => "sendAOCS_TM";
    Taste::labelInheritance => "true";
  };
  RI_receiveP1_TC : REQUIRES SUBPROGRAM ACCESS interfaceview::IV::Payload1::PI_receiveP1_TC.others {
    Taste::coordinates => "122619 84235";
    Taste::RCMoperationKind => any;
    Taste::InterfaceName => "receiveP1_TC";
    Taste::labelInheritance => "true";
  };
  RI_receiveP2_TC : REQUIRES SUBPROGRAM ACCESS interfaceview::IV::Payload2::PI_receiveP2_TC.others {
    Taste::coordinates => "122619 88375";
    Taste::RCMoperationKind => any;
    Taste::InterfaceName => "receiveP2_TC";
    Taste::labelInheritance => "true";
  };
PROPERTIES
  Source_Language => (C);
  Taste::Active_Interfaces => any;
END TM_TC;

SYSTEM IMPLEMENTATION TM_TC.others
END TM_TC.others;

END interfaceview::IV::TM_TC;

PACKAGE interfaceview::IV::Payload1
PUBLIC

WITH interfaceview::IV::TM_TC;
WITH Taste;
WITH DataView;
WITH TASTE_IV_Properties;
SUBPROGRAM PI_receiveP1_TC
FEATURES
  TC : IN PARAMETER DataView::MyEnum {
    Taste::encoding => NATIVE;
  };
PROPERTIES
  Taste::Associated_Queue_Size => 1;
END PI_receiveP1_TC;

SUBPROGRAM IMPLEMENTATION PI_receiveP1_TC.others
PROPERTIES
  Compute_Execution_Time => 0 ms .. 2 ms;
END PI_receiveP1_TC.others;

SUBPROGRAM RI_receiveP1_TM
FEATURES
  TM : IN PARAMETER DataView::MyInteger {
    Taste::encoding => NATIVE;
  };
END RI_receiveP1_TM;

SUBPROGRAM IMPLEMENTATION RI_receiveP1_TM.others
END RI_receiveP1_TM.others;

SYSTEM Payload1
FEATURES
  PI_receiveP1_TC : PROVIDES SUBPROGRAM ACCESS interfaceview::IV::Payload1::PI_receiveP1_TC.others {
    Taste::coordinates => "135408 67346";
    Taste::RCMoperationKind => sporadic;
    Taste::RCMperiod => 200 ms;
    Taste::Deadline => 200 ms;
    Taste::InterfaceName => "receiveP1_TC";
  };
  RI_receiveP1_TM : REQUIRES SUBPROGRAM ACCESS interfaceview::IV::TM_TC::PI_receiveP1_TM.others {
    Taste::coordinates => "135408 72680";
    Taste::RCMoperationKind => any;
    Taste::InterfaceName => "receiveP1_TM";
    Taste::labelInheritance => "true";
  };
PROPERTIES
  Source_Language => (C);
  Taste::Active_Interfaces => any;
END Payload1;

SYSTEM IMPLEMENTATION Payload1.others
END Payload1.others;

END interfaceview::IV::Payload1;

PACKAGE interfaceview::IV::Payload2
PUBLIC

WITH interfaceview::IV::TM_TC;
WITH Taste;
WITH DataView;
WITH TASTE_IV_Properties;
SUBPROGRAM PI_receiveP2_TC
PROPERTIES
  Taste::Associated_Queue_Size => 1;
END PI_receiveP2_TC;

SUBPROGRAM IMPLEMENTATION PI_receiveP2_TC.others
PROPERTIES
  Compute_Execution_Time => 0 ms .. 5 ms;
END PI_receiveP2_TC.others;

SUBPROGRAM RI_receiveP2_TM
FEATURES
  TM : IN PARAMETER DataView::MyInteger {
    Taste::encoding => NATIVE;
  };
END RI_receiveP2_TM;

SUBPROGRAM IMPLEMENTATION RI_receiveP2_TM.others
END RI_receiveP2_TM.others;

SYSTEM Payload2
FEATURES
  PI_receiveP2_TC : PROVIDES SUBPROGRAM ACCESS interfaceview::IV::Payload2::PI_receiveP2_TC.others {
    Taste::coordinates => "145759 84871";
    Taste::RCMoperationKind => sporadic;
    Taste::RCMperiod => 300 ms;
    Taste::Deadline => 300 ms;
    Taste::InterfaceName => "receiveP2_TC";
  };
  RI_receiveP2_TM : REQUIRES SUBPROGRAM ACCESS interfaceview::IV::TM_TC::PI_receiveP2_TM.others {
    Taste::coordinates => "145759 89219";
    Taste::RCMoperationKind => any;
    Taste::InterfaceName => "receiveP2_TM";
    Taste::labelInheritance => "true";
  };
PROPERTIES
  Source_Language => (C);
  Taste::Active_Interfaces => any;
END Payload2;

SYSTEM IMPLEMENTATION Payload2.others
END Payload2.others;

END interfaceview::IV::Payload2;

PACKAGE interfaceview::IV
PUBLIC

WITH interfaceview::IV::AOCS;
WITH interfaceview::IV::TM_TC;
WITH interfaceview::IV::Payload1;
WITH interfaceview::IV::Payload2;
WITH Taste;
WITH DataView;
WITH TASTE_IV_Properties;
SYSTEM interfaceview
END interfaceview;

SYSTEM IMPLEMENTATION interfaceview.others
SUBCOMPONENTS
  AOCS : SYSTEM interfaceview::IV::AOCS::AOCS.others {
    Taste::coordinates => "96107 58286 121988 74960";
    Taste::Fill_Color => "#ff8000";
  };
  TM_TC : SYSTEM interfaceview::IV::TM_TC::TM_TC.others {
    Taste::coordinates => "95949 82165 122619 96725";
    Taste::Fill_Color => "#80ffff";
  };
  Payload1 : SYSTEM interfaceview::IV::Payload1::Payload1.others {
    Taste::coordinates => "135408 65071 151018 75475";
    Taste::Fill_Color => "#ff80c0";
  };
  Payload2 : SYSTEM interfaceview::IV::Payload2::Payload2.others {
    Taste::coordinates => "145759 81766 161635 92229";
    Taste::Fill_Color => "#ff80c0";
  };
CONNECTIONS
  AOCS_PI_receiveAOCS_TC_TM_TC_RI_receiveAOCS_TC : SUBPROGRAM ACCESS AOCS.PI_receiveAOCS_TC -> TM_TC.RI_receiveAOCS_TC {
    Taste::coordinates => "101717 82165 101717 77773 103247 77773 103247 74960";
  };
  AOCS_PI_sendAOCS_TM_TM_TC_RI_sendAOCS_TM : SUBPROGRAM ACCESS AOCS.PI_sendAOCS_TM -> TM_TC.RI_sendAOCS_TM {
    Taste::coordinates => "112276 82165 112276 77773 113808 77773 113808 74960";
  };
  TM_TC_PI_receiveP1_TM_Payload1_RI_receiveP1_TM : SUBPROGRAM ACCESS TM_TC.PI_receiveP1_TM -> Payload1.RI_receiveP1_TM {
    Taste::coordinates => "135408 72680 131299 72680 131299 86305 122619 86305";
  };
  TM_TC_PI_receiveP2_TM_Payload2_RI_receiveP2_TM : SUBPROGRAM ACCESS TM_TC.PI_receiveP2_TM -> Payload2.RI_receiveP2_TM {
    Taste::coordinates => "145759 89219 135086 89219 135086 90445 122619 90445";
  };
  Payload1_PI_receiveP1_TC_TM_TC_RI_receiveP1_TC : SUBPROGRAM ACCESS Payload1.PI_receiveP1_TC -> TM_TC.RI_receiveP1_TC {
    Taste::coordinates => "122619 84235 129013 84235 129013 67346 135408 67346";
  };
  Payload2_PI_receiveP2_TC_TM_TC_RI_receiveP2_TC : SUBPROGRAM ACCESS Payload2.PI_receiveP2_TC -> TM_TC.RI_receiveP2_TC {
    Taste::coordinates => "122619 88375 133666 88375 133666 84871 145759 84871";
  };
END interfaceview.others;

PROPERTIES
  Taste::dataView => ("DataView");
  Taste::dataViewPath => ("dataview.aadl");
  Taste::coordinates => "0 0 297000 210000";
  Taste::version => "2.0";
END interfaceview::IV;




---------------------------------------------------
-- AADL2.1
-- TASTE type deploymentview
-- 
-- generated code: do not edit
---------------------------------------------------

PACKAGE deploymentview::DV::Platform
PUBLIC

WITH ocarina_buses;
WITH ocarina_drivers;
WITH Taste;
WITH Deployment;
WITH TASTE_DV_Properties;
PROCESS Partition0
END Partition0;

PROCESS IMPLEMENTATION Partition0.others
END Partition0.others;

VIRTUAL PROCESSOR Partition0_VP
END Partition0_VP;

VIRTUAL PROCESSOR IMPLEMENTATION Partition0_VP.others
END Partition0_VP.others;

PROCESS Partition1
END Partition1;

PROCESS IMPLEMENTATION Partition1.others
END Partition1.others;

VIRTUAL PROCESSOR Partition1_VP
END Partition1_VP;

VIRTUAL PROCESSOR IMPLEMENTATION Partition1_VP.others
END Partition1_VP.others;

DEVICE generic_serial_raw
EXTENDS ocarina_drivers::generic_serial
FEATURES
  link : REFINED TO REQUIRES BUS ACCESS ocarina_buses::serial.generic {
    Taste::coordinates => "113782 105575";
  };
PROPERTIES
  Taste::Interface_Coordinates => "143923 98316" APPLIES TO link;
  Deployment::Help => "Write your ASN.1 configuration here";
  Deployment::Configuration => "generic_serial_raw";
  Deployment::Config => "/home/maxime/taste/tool-inst/include/ocarina/runtime/polyorb-hi-c/src/drivers/configuration/serial.asn";
  Deployment::Version => "0.1beta";
END generic_serial_raw;

DEVICE IMPLEMENTATION generic_serial_raw.others
EXTENDS ocarina_drivers::generic_serial.raw
END generic_serial_raw.others;

MEMORY main_memory
END main_memory;

MEMORY IMPLEMENTATION main_memory.others
SUBCOMPONENTS
  Partition0_Segment : MEMORY deploymentview::DV::partition_memory.others {
    Base_Address => 16#A000#;
    Memory_Size => 16#1000# Bytes;
  };
  Partition1_Segment : MEMORY deploymentview::DV::partition_memory.others {
    Base_Address => 16#B000#;
    Memory_Size => 16#1000# Bytes;
  };
END main_memory.others;

END deploymentview::DV::Platform;

PACKAGE deploymentview::DV::Payload
PUBLIC

WITH ocarina_buses;
WITH ocarina_drivers;
WITH Taste;
WITH Deployment;
WITH TASTE_DV_Properties;
PROCESS x86_partition
END x86_partition;

PROCESS IMPLEMENTATION x86_partition.others
END x86_partition.others;

DEVICE generic_serial_raw
EXTENDS ocarina_drivers::generic_serial
FEATURES
  link : REFINED TO REQUIRES BUS ACCESS ocarina_buses::serial.generic {
    Taste::coordinates => "166175 65118";
  };
PROPERTIES
  Taste::Interface_Coordinates => "143450 71961" APPLIES TO link;
  Deployment::Help => "Write your ASN.1 configuration here";
  Deployment::Configuration => "generic_serial_raw";
  Deployment::Config => "/home/maxime/taste/tool-inst/include/ocarina/runtime/polyorb-hi-c/src/drivers/configuration/serial.asn";
  Deployment::Version => "0.1beta";
END generic_serial_raw;

DEVICE IMPLEMENTATION generic_serial_raw.others
EXTENDS ocarina_drivers::generic_serial.raw
END generic_serial_raw.others;

END deploymentview::DV::Payload;

PACKAGE deploymentview::DV
PUBLIC

WITH interfaceview::IV::AOCS;
WITH interfaceview::IV::TM_TC;
WITH ocarina_processors_leon;
WITH ARINC653;
WITH deploymentview::DV::Platform;
WITH interfaceview::IV::Payload1;
WITH interfaceview::IV::Payload2;
WITH ocarina_processors_x86;
WITH deploymentview::DV::Payload;
WITH ocarina_buses;
WITH Taste;
WITH Deployment;
WITH interfaceview::IV;
WITH TASTE_DV_Properties;
MEMORY partition_memory
END partition_memory;

MEMORY IMPLEMENTATION partition_memory.others
END partition_memory.others;

SYSTEM Platform
FEATURES
  generic_serial_raw_serial_generic : REQUIRES BUS ACCESS ocarina_buses::serial.generic;
END Platform;

SYSTEM IMPLEMENTATION Platform.others
SUBCOMPONENTS
  IV_AOCS : SYSTEM interfaceview::IV::AOCS::AOCS.others {
    Taste::FunctionName => "AOCS";
  };
  Partition0 : PROCESS deploymentview::DV::Platform::Partition0.others {
    Taste::coordinates => "99891 69515 126252 83797";
    Deployment::Port_Number => 0;
  };
  Partition0_VP : VIRTUAL PROCESSOR deploymentview::DV::Platform::Partition0_VP.others {
    Scheduling_Protocol => (POSIX_1003_Highest_Priority_First_Protocol);
    ARINC653::DAL => LEVEL_A;
  };
  IV_TM_TC : SYSTEM interfaceview::IV::TM_TC::TM_TC.others {
    Taste::FunctionName => "TM_TC";
  };
  Partition1 : PROCESS deploymentview::DV::Platform::Partition1.others {
    Taste::coordinates => "99737 86322 125933 97685";
    Deployment::Port_Number => 0;
  };
  Partition1_VP : VIRTUAL PROCESSOR deploymentview::DV::Platform::Partition1_VP.others {
    Scheduling_Protocol => (POSIX_1003_Highest_Priority_First_Protocol);
    ARINC653::DAL => LEVEL_A;
  };
  leon_rtems_posix : PROCESSOR ocarina_processors_leon::leon.rtems_posix {
    Taste::coordinates => "96438 63440 129389 99342";
    Scheduling_Protocol => (ARINC653);
  };
  generic_serial_raw : DEVICE deploymentview::DV::Platform::generic_serial_raw.others {
    Taste::coordinates => "103682 103208 113782 108258";
    Taste::Fill_Color => "#408080";
  };
  main_memory : MEMORY deploymentview::DV::Platform::main_memory.others;
CONNECTIONS
  generic_serial_raw_serial_generic_link : BUS ACCESS generic_serial_raw_serial_generic -> generic_serial_raw.link;
PROPERTIES
  Taste::APLC_Binding => (reference (Partition0)) APPLIES TO IV_AOCS;
  Actual_Processor_Binding => (reference (leon_rtems_posix)) APPLIES TO Partition0_VP;
  Actual_Processor_Binding => (reference (Partition0_VP)) APPLIES TO Partition0;
  Actual_Memory_Binding  => (reference (main_memory.Partition0_Segment)) APPLIES TO Partition0;
  Taste::APLC_Binding => (reference (Partition1)) APPLIES TO IV_TM_TC;
  Actual_Processor_Binding => (reference (leon_rtems_posix)) APPLIES TO Partition1_VP;
  Actual_Processor_Binding => (reference (Partition1_VP)) APPLIES TO Partition1;
  Actual_Memory_Binding  => (reference (main_memory.Partition1_Segment)) APPLIES TO Partition1;
  ARINC653::Module_Major_Frame => 100ms APPLIES TO leon_rtems_posix;
  ARINC653::Module_Schedule => (
	[ Partition => reference(Partition0_VP);
	  Duration => 50ms;
	  Periodic_Processing_Start => False; ],
	[ Partition => reference(Partition1_VP);
	  Duration => 50ms;
	  Periodic_Processing_Start => False; ]
) APPLIES TO leon_rtems_posix;
  Actual_Processor_Binding => (reference (leon_rtems_posix)) APPLIES TO generic_serial_raw;
END Platform.others;

SYSTEM Payload
FEATURES
  generic_serial_raw_serial_generic : REQUIRES BUS ACCESS ocarina_buses::serial.generic;
END Payload;

SYSTEM IMPLEMENTATION Payload.others
SUBCOMPONENTS
  IV_Payload1 : SYSTEM interfaceview::IV::Payload1::Payload1.others {
    Taste::FunctionName => "Payload1";
  };
  IV_Payload2 : SYSTEM interfaceview::IV::Payload2::Payload2.others {
    Taste::FunctionName => "Payload2";
  };
  x86_partition : PROCESS deploymentview::DV::Payload::x86_partition.others {
    Taste::coordinates => "163703 80044 190267 94213";
    Deployment::Port_Number => 0;
    Taste::Fill_Color => "#ff80c0";
  };
  x86_linux32 : PROCESSOR ocarina_processors_x86::x86.linux32 {
    Taste::coordinates => "160383 72687 193587 109473";
  };
  generic_serial_raw : DEVICE deploymentview::DV::Payload::generic_serial_raw.others {
    Taste::coordinates => "166175 62651 178326 67584";
    Taste::Fill_Color => "#408080";
  };
CONNECTIONS
  generic_serial_raw_serial_generic_link : BUS ACCESS generic_serial_raw_serial_generic -> generic_serial_raw.link;
PROPERTIES
  Taste::APLC_Binding => (reference (x86_partition)) APPLIES TO IV_Payload1;
  Taste::APLC_Binding => (reference (x86_partition)) APPLIES TO IV_Payload2;
  Actual_Processor_Binding => (reference (x86_linux32)) APPLIES TO x86_partition;
  Actual_Processor_Binding => (reference (x86_linux32)) APPLIES TO generic_serial_raw;
END Payload.others;

SYSTEM deploymentview
END deploymentview;

SYSTEM IMPLEMENTATION deploymentview.others
SUBCOMPONENTS
  Platform : SYSTEM Platform.others {
    Taste::coordinates => "92319 59179 133508 110468";
  };
  Payload : SYSTEM Payload.others {
    Taste::coordinates => "156233 59179 197737 111730";
  };
  serial_generic : BUS ocarina_buses::serial.generic {
    Taste::coordinates => "139189 71961 148099 98316";
    Taste::Fill_Color => "#408080";
  };
  interfaceview : SYSTEM interfaceview::IV::interfaceview.others;
CONNECTIONS
  Connection1 : BUS ACCESS serial_generic -> Platform.generic_serial_raw_serial_generic {
    Taste::coordinates => "113782 105575 143923 105575 143923 98316";
  };
  Connection2 : BUS ACCESS serial_generic -> Payload.generic_serial_raw_serial_generic {
    Taste::coordinates => "166175 65118 143450 65118 143450 71961";
  };
PROPERTIES
  Actual_Connection_Binding => (reference (serial_generic)) APPLIES TO interfaceview.Payload1_PI_receiveP1_TC_TM_TC_RI_receiveP1_TC;
  Actual_Connection_Binding => (reference (serial_generic)) APPLIES TO interfaceview.Payload2_PI_receiveP2_TC_TM_TC_RI_receiveP2_TC;
  Actual_Connection_Binding => (reference (serial_generic)) APPLIES TO interfaceview.TM_TC_PI_receiveP1_TM_Payload1_RI_receiveP1_TM;
  Actual_Connection_Binding => (reference (serial_generic)) APPLIES TO interfaceview.TM_TC_PI_receiveP2_TM_Payload2_RI_receiveP2_TM;
END deploymentview.others;

PROPERTIES
  Taste::coordinates => "0 0 297000 210000";
  Taste::version => "2.0";
  Taste::interfaceView => "interfaceview.aadl";
  Taste::HWLibraries => ("libhw.aadl");
END deploymentview::DV;




-- type dataview
--------------------------------------------------------
--! File generated by asn2aadl v1.2160: DO NOT EDIT !
--------------------------------------------------------

package DataView

public

  with Data_Model;
  with Taste;
  with Base_Types;
  with Deployment;
-- No more private heap required (we use the space certified compiler)
-- Memory_Required: 0


data Stream_Element_Buffer
    -- Root type for buffer elements
properties
    Data_Model::Data_Representation => Character;
end Stream_Element_Buffer;
DATA MyInteger
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("TASTE-Dataview.asn");
    TASTE::Ada_Package_Name => "TASTE_Dataview";
    Deployment::ASN1_Module_Name => "TASTE-Dataview";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 8; suggested aligned message buffer is...
    Source_Data_Size => 8 Bytes;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "MyInteger";
    -- what kind of type is this?
    TASTE::ASN1_Basic_Type =>aINTEGER;
END MyInteger;

DATA MyInteger_Buffer_Max
END MyInteger_Buffer_Max;

DATA IMPLEMENTATION MyInteger_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type MyInteger
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (classifier (DataView::Stream_Element_Buffer));
END MyInteger_Buffer_Max.impl;

DATA MyInteger_Buffer
END MyInteger_Buffer;

DATA IMPLEMENTATION MyInteger_Buffer.impl
    -- Buffer to hold a marshalled data of type MyInteger
SUBCOMPONENTS
    Buffer : data MyInteger_Buffer_Max.impl;
    Length : data Base_Types::Unsigned_16;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END MyInteger_Buffer.impl;

DATA MyReal
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("TASTE-Dataview.asn");
    TASTE::Ada_Package_Name => "TASTE_Dataview";
    Deployment::ASN1_Module_Name => "TASTE-Dataview";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 13; suggested aligned message buffer is...
    Source_Data_Size => 16 Bytes;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "MyReal";
    -- what kind of type is this?
    TASTE::ASN1_Basic_Type =>aREAL;
END MyReal;

DATA MyReal_Buffer_Max
END MyReal_Buffer_Max;

DATA IMPLEMENTATION MyReal_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type MyReal
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (16); -- Size of the buffer
    Data_Model::Base_Type => (classifier (DataView::Stream_Element_Buffer));
END MyReal_Buffer_Max.impl;

DATA MyReal_Buffer
END MyReal_Buffer;

DATA IMPLEMENTATION MyReal_Buffer.impl
    -- Buffer to hold a marshalled data of type MyReal
SUBCOMPONENTS
    Buffer : data MyReal_Buffer_Max.impl;
    Length : data Base_Types::Unsigned_16;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END MyReal_Buffer.impl;

DATA MySeqOf
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("TASTE-Dataview.asn");
    TASTE::Ada_Package_Name => "TASTE_Dataview";
    Deployment::ASN1_Module_Name => "TASTE-Dataview";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 8; suggested aligned message buffer is...
    Source_Data_Size => 8 Bytes;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "MySeqOf";
    -- what kind of type is this?
    TASTE::ASN1_Basic_Type =>aSEQUENCEOF;
END MySeqOf;

DATA MySeqOf_Buffer_Max
END MySeqOf_Buffer_Max;

DATA IMPLEMENTATION MySeqOf_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type MySeqOf
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (classifier (DataView::Stream_Element_Buffer));
END MySeqOf_Buffer_Max.impl;

DATA MySeqOf_Buffer
END MySeqOf_Buffer;

DATA IMPLEMENTATION MySeqOf_Buffer.impl
    -- Buffer to hold a marshalled data of type MySeqOf
SUBCOMPONENTS
    Buffer : data MySeqOf_Buffer_Max.impl;
    Length : data Base_Types::Unsigned_16;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END MySeqOf_Buffer.impl;

DATA MySeq
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("TASTE-Dataview.asn");
    TASTE::Ada_Package_Name => "TASTE_Dataview";
    Deployment::ASN1_Module_Name => "TASTE-Dataview";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 12; suggested aligned message buffer is...
    Source_Data_Size => 16 Bytes;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "MySeq";
    -- what kind of type is this?
    TASTE::ASN1_Basic_Type =>aSEQUENCE;
END MySeq;

DATA MySeq_Buffer_Max
END MySeq_Buffer_Max;

DATA IMPLEMENTATION MySeq_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type MySeq
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (16); -- Size of the buffer
    Data_Model::Base_Type => (classifier (DataView::Stream_Element_Buffer));
END MySeq_Buffer_Max.impl;

DATA MySeq_Buffer
END MySeq_Buffer;

DATA IMPLEMENTATION MySeq_Buffer.impl
    -- Buffer to hold a marshalled data of type MySeq
SUBCOMPONENTS
    Buffer : data MySeq_Buffer_Max.impl;
    Length : data Base_Types::Unsigned_16;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END MySeq_Buffer.impl;

DATA MyEnum
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("TASTE-Dataview.asn");
    TASTE::Ada_Package_Name => "TASTE_Dataview";
    Deployment::ASN1_Module_Name => "TASTE-Dataview";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 4; suggested aligned message buffer is...
    Source_Data_Size => 8 Bytes;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "MyEnum";
    -- what kind of type is this?
    TASTE::ASN1_Basic_Type =>aENUMERATED;
END MyEnum;

DATA MyEnum_Buffer_Max
END MyEnum_Buffer_Max;

DATA IMPLEMENTATION MyEnum_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type MyEnum
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (classifier (DataView::Stream_Element_Buffer));
END MyEnum_Buffer_Max.impl;

DATA MyEnum_Buffer
END MyEnum_Buffer;

DATA IMPLEMENTATION MyEnum_Buffer.impl
    -- Buffer to hold a marshalled data of type MyEnum
SUBCOMPONENTS
    Buffer : data MyEnum_Buffer_Max.impl;
    Length : data Base_Types::Unsigned_16;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END MyEnum_Buffer.impl;

DATA MyChoice
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("TASTE-Dataview.asn");
    TASTE::Ada_Package_Name => "TASTE_Dataview";
    Deployment::ASN1_Module_Name => "TASTE-Dataview";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 16; suggested aligned message buffer is...
    Source_Data_Size => 16 Bytes;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "MyChoice";
    -- what kind of type is this?
    TASTE::ASN1_Basic_Type =>aCHOICE;
END MyChoice;

DATA MyChoice_Buffer_Max
END MyChoice_Buffer_Max;

DATA IMPLEMENTATION MyChoice_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type MyChoice
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (16); -- Size of the buffer
    Data_Model::Base_Type => (classifier (DataView::Stream_Element_Buffer));
END MyChoice_Buffer_Max.impl;

DATA MyChoice_Buffer
END MyChoice_Buffer;

DATA IMPLEMENTATION MyChoice_Buffer.impl
    -- Buffer to hold a marshalled data of type MyChoice
SUBCOMPONENTS
    Buffer : data MyChoice_Buffer_Max.impl;
    Length : data Base_Types::Unsigned_16;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END MyChoice_Buffer.impl;

DATA MyOctStr
PROPERTIES
    -- name of the ASN.1 source file:
    Source_Text => ("dataview.asn");
    TASTE::Ada_Package_Name => "TASTE_Dataview";
    Deployment::ASN1_Module_Name => "TASTE-Dataview";
    Source_Language => (ASN1);
    -- Size of a buffer to cover all forms of message representation:
    -- Real message size is 3; suggested aligned message buffer is...
    Source_Data_Size => 8 Bytes;
    -- name of the corresponding data type in the source file:
    Type_Source_Name => "MyOctStr";
    -- what kind of type is this?
    TASTE::ASN1_Basic_Type =>aSTRING;
END MyOctStr;

DATA MyOctStr_Buffer_Max
END MyOctStr_Buffer_Max;

DATA IMPLEMENTATION MyOctStr_Buffer_Max.impl
    -- Buffer to hold a marshalled data of type MyOctStr
PROPERTIES
    Data_Model::Data_Representation => array;
    Data_Model::Dimension => (8); -- Size of the buffer
    Data_Model::Base_Type => (classifier (DataView::Stream_Element_Buffer));
END MyOctStr_Buffer_Max.impl;

DATA MyOctStr_Buffer
END MyOctStr_Buffer;

DATA IMPLEMENTATION MyOctStr_Buffer.impl
    -- Buffer to hold a marshalled data of type MyOctStr
SUBCOMPONENTS
    Buffer : data MyOctStr_Buffer_Max.impl;
    Length : data Base_Types::Unsigned_16;
PROPERTIES
    Data_Model::Data_Representation => Struct;
END MyOctStr_Buffer.impl;

end DataView;



-- type hwlibrary

package ocarina_buses

public

bus generic_bus
end generic_bus;

bus implementation generic_bus.i
end generic_bus.i;

bus dummy_bus
end dummy_bus;

bus implementation dummy_bus.i
end dummy_bus.i;

bus ip
end ip;

bus implementation ip.pohic
end ip.pohic;

bus implementation ip.i
subcomponents
   asn      : virtual bus asn1.i;
   pohic    : virtual bus pohi.c;
   pohiada  : virtual bus pohi.ada;
end ip.i;

bus implementation ip.pohiada
end ip.pohiada;

bus spacewire
end spacewire;

bus implementation spacewire.generic
end spacewire.generic;

bus serial
end serial;

bus implementation serial.generic
end serial.generic;


----------------------
--  Virtual buses  --
----------------------

virtual bus raw
end raw;

virtual bus implementation raw.i
end raw.i;

virtual bus asn1
end asn1;

virtual bus implementation asn1.i
end asn1.i;

virtual bus pohi
end pohi;

virtual bus implementation pohi.c
end pohi.c;

virtual bus implementation pohi.ada
end pohi.ada;

end ocarina_buses;
package ocarina_drivers
public

  with deployment;

  with ocarina_buses;

  with Data_Model;
  with Base_Types;

  with ocarina_drivers_leon_serial;

  with ocarina_drivers_rasta_1553;
  with ocarina_drivers_rasta_serial;
  with ocarina_drivers_rasta_spacewire;
  with ocarina_drivers_rtems_ne2000;

  with ocarina_drivers_star_dundee_spacewire_brick;

  with ocarina_drivers_udp_exarm;
  with ocarina_drivers_serial;

  with ocarina_drivers_ip_pohic;

  with ocarina_drivers_exarm_ni_6071e_analog;
  with ocarina_drivers_exarm_ni_6071e_digital;

  with ocarina_drivers_generic_keyboard;

  with GRUART;
  with GRSPW;
  with Native_UART;
  with TCP_IP_Protocol;

  ------------------------
  -- Configuration Type --
  ------------------------

   data configuration_type_ip
   properties
      Type_Source_Name                 => "IP-Conf-T";
      Deployment::ASN1_Module_Name     => "POHICDRIVER-IP";
      Source_Language                  => (ASN1);
      Source_Text                      => ("/home/maxime/taste/tool-inst/include/ocarina/runtime/polyorb-hi-c/src/drivers/configuration/ip.asn" , "drivers/configuration/ip.h");
   end configuration_type_ip;

   data configuration_type_serial
   properties
      Type_Source_Name              => "Serial-Conf-T";
      Deployment::ASN1_Module_Name  => "POHICDRIVER-UART";
      Source_Language               => (ASN1);
      Source_Text                   => ("/home/maxime/taste/tool-inst/include/ocarina/runtime/polyorb-hi-c/src/drivers/configuration/serial.asn", "drivers/configuration/serial.h");
   end configuration_type_serial;

   data configuration_type_spacewire
   properties
      Type_Source_Name              => "Spacewire-Conf-T";
      Deployment::ASN1_Module_Name  => "POHICDRIVER-SPACEWIRE";
      Source_Language               => (ASN1);
      Source_Text                   => ("/home/maxime/taste/tool-inst/include/ocarina/runtime/polyorb-hi-c/src/drivers/configuration/spacewire.asn", "drivers/configuration/spacewire.h");
   end configuration_type_spacewire;

  --------------
  -- Keyboard --
  --------------

  device generic_keyboard
  features
    key_pressed  : out data port Base_Types::Character;
  properties
    Deployment::Driver_Name    => "generic_keyboard";
    Device_Driver              => classifier (ocarina_drivers_generic_keyboard::generic_keyboard_driver.i);
    Initialize_Entrypoint      => classifier (ocarina_drivers_generic_keyboard::spg_generic_keyboard_init);
  end generic_keyboard;

  device implementation generic_keyboard.linux
  end generic_keyboard.linux;


  -------------------
  -- LEON ETHERNET --
  -------------------

  device leon_ethernet
  features
    link : requires bus access ocarina_buses::ip.i;
  end leon_ethernet;

  device implementation leon_ethernet.raw
  properties
    Deployment::Driver_Name    => "eth_leon";
    Device_Driver              => classifier (ocarina_drivers_leon_eth::eth_driver.leon);
    Initialize_Entrypoint      => classifier (ocarina_drivers_leon_eth::spg_leon_eth_init);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::pohi.c));
  end leon_ethernet.raw;


  ------------------
  -- RASTA SERIAL --
  ------------------

  device leon_serial
  features
    link : requires bus access ocarina_buses::serial.generic;
  end leon_serial;

  device implementation leon_serial.raw
  properties
    Deployment::Driver_Name    => "serial_leon";
    Device_Driver              => classifier (ocarina_drivers_leon_serial::serial_driver.leon);
    Initialize_Entrypoint      => classifier (ocarina_drivers_leon_serial::spg_serial_init_leon);
    Provided_Virtual_Bus_Class => (classifier (ocarina_buses::raw.i));
  end leon_serial.raw;

  device implementation leon_serial.raw_sender
  properties
    Deployment::Driver_Name    => "serial_leon_sender";
    Device_Driver              => classifier (ocarina_drivers_leon_serial::serial_driver.leon_sender);
    Initialize_Entrypoint      => classifier (ocarina_drivers_leon_serial::spg_serial_init_leon_sender);
    Provided_Virtual_Bus_Class => (classifier (ocarina_buses::raw.i));
  end leon_serial.raw_sender;

  ----------------
  -- RASTA 1553 --
  ----------------

  device rasta_1553
  end rasta_1553;

  device implementation rasta_1553.terminal
  properties
    Deployment::Driver_Name    => "1553_rasta";
    Device_Driver              => classifier (ocarina_drivers_rasta_1553::if1553_driver.rasta_terminal);
    Initialize_Entrypoint      => classifier (ocarina_drivers_rasta_1553::spg_1553_init_rasta_terminal);
    Provided_Virtual_Bus_Class => (classifier (ocarina_buses::pohi.c));
  end rasta_1553.terminal;

  device implementation rasta_1553.controller_sender_only
  properties
    Deployment::Driver_Name    => "1553_rasta";
    Device_Driver              => classifier (ocarina_drivers_rasta_1553::if1553_driver.rasta_controller_sender_only);
    Initialize_Entrypoint      => classifier (ocarina_drivers_rasta_1553::spg_1553_init_rasta_controller);
    Provided_Virtual_Bus_Class => (classifier (ocarina_buses::pohi.c));
  end rasta_1553.controller_sender_only;

  ------------------
  -- RASTA SERIAL --
  ------------------

  device rasta_serial
  features
    link : requires bus access ocarina_buses::serial.generic;
  end rasta_serial;

  device implementation rasta_serial.raw
  properties
    Deployment::Driver_Name    => "serial_rasta";
    Device_Driver              => classifier (ocarina_drivers_rasta_serial::serial_driver.rasta);
    Initialize_Entrypoint      => classifier (ocarina_drivers_rasta_serial::spg_serial_init_rasta);
    Provided_Virtual_Bus_Class => (classifier (ocarina_buses::raw.i));
  end rasta_serial.raw;

  device implementation rasta_serial.pohiada
  properties
    Deployment::Driver_Name    => "serial_rasta";
    Implemented_As =>  classifier (GRUART::Driver_GRUART_Protocol.impl);
    Initialize_Entrypoint => classifier (GRUART::Initialize);
    Provided_Virtual_Bus_Class => (classifier (ocarina_buses::raw.i));
    Allowed_Processor_Binding_Class => (classifier(Generic_Native::Generic_Processor.impl),classifier(GR_CPCI_X4CV::LEON2.impl));
  end rasta_serial.pohiada;

  --------------------------------------------------
  -- USB BRICK (STAR DUNDEE) DEVICE FOR SPACEWIRE --
  --------------------------------------------------

  device usb_brick_spacewire
  features
    link : requires bus access ocarina_buses::spacewire.generic;
  end usb_brick_spacewire;

  device implementation usb_brick_spacewire.pohic
  properties
    Deployment::Driver_Name       => "spacewire_usb_brick";
    Device_Driver                 => classifier (ocarina_drivers_star_dundee_spacewire_brick::driver.usb_brick);
    Initialize_Entrypoint         => classifier (ocarina_drivers_star_dundee_spacewire_brick::spg_init);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::pohi.c));
  end usb_brick_spacewire.pohic;

  ---------------------
  -- RASTA SPACEWIRE --
  ---------------------

  device rasta_spacewire
  features
    link : requires bus access ocarina_buses::spacewire.generic;
  end rasta_spacewire;

  device implementation rasta_spacewire.pohic
  properties
    Deployment::Driver_Name       => "spacewire_rasta";
    Device_Driver                 => classifier (ocarina_drivers_rasta_spacewire::spacewire_driver.rasta);
    Initialize_Entrypoint         => classifier (ocarina_drivers_rasta_spacewire::spg_spacewire_init_rasta);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::pohi.c));
  end rasta_spacewire.pohic;

  device implementation rasta_spacewire.pohiada
  properties
    Deployment::Driver_Name       => "spacewire_rasta";
    Implemented_As =>  classifier (GRSPW::Driver_GRSPW_Protocol.impl);
    Initialize_Entrypoint => classifier (GRSPW::Initialize);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::pohi.c));
  end rasta_spacewire.pohiada;


  ---------------------
  -- SCOC3 SPACEWIRE --
  ---------------------

  device scoc3_spacewire
  features
    link : requires bus access ocarina_buses::spacewire.generic;
  end scoc3_spacewire;

  device implementation scoc3_spacewire.pohic
  properties
    Deployment::Driver_Name       => "spacewire_scoc3";
    Device_Driver                 => classifier (ocarina_drivers_scoc3_spacewire::driver.i);
    Initialize_Entrypoint         => classifier (ocarina_drivers_scoc3_spacewire::spg_init);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::pohi.c));
  end scoc3_spacewire.pohic;

  ---------------------------
  -- Generic serial driver --
  ---------------------------

  device generic_serial
  features
    link : requires bus access ocarina_buses::serial.generic;
  end generic_serial;

  device implementation generic_serial.raw
  properties
    Deployment::Driver_Name       => "serial_linux";
    Device_Driver                 => classifier (ocarina_drivers_serial::serial_driver.linux);
    Initialize_Entrypoint         => classifier (ocarina_drivers_serial::spg_serial_init_linux);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::raw.i));
  end generic_serial.raw;

  device implementation generic_serial.pohiada
  properties
    Deployment::Driver_Name       => "serial_linux";
    Implemented_As =>
         classifier (Native_UART::Driver_Native_UART_Protocol.impl);
    Initialize_Entrypoint => classifier (Native_UART::Initialize);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::raw.i));
  end generic_serial.pohiada;

  device implementation generic_serial.raw_sender
  properties
    Deployment::Driver_Name       => "serial_linux_sender";
    Device_Driver                 => classifier (ocarina_drivers_serial::serial_driver.linux_sender);
    Initialize_Entrypoint         => classifier (ocarina_drivers_serial::spg_serial_init_linux_sender);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::raw.i));
  end generic_serial.raw_sender;

  device implementation generic_serial.raw_receiver
  properties
    Deployment::Driver_Name       => "serial_linux_receiver";
    Device_Driver                 => classifier (ocarina_drivers_serial::serial_driver.linux_receiver);
    Initialize_Entrypoint         => classifier (ocarina_drivers_serial::spg_serial_init_linux_receiver);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::raw.i));
  end generic_serial.raw_receiver;

  -------------------------------
  -- Generic sockets/ip driver --
  -------------------------------

  device generic_sockets_ip
  features
    link : requires bus access ocarina_buses::ip.i;
  end generic_sockets_ip;

  device implementation generic_sockets_ip.pohic
  properties
    Deployment::Driver_Name       => "sockets";
    Device_Driver                 => classifier (ocarina_drivers_ip_pohic::sockets_impl.i);
    Initialize_Entrypoint         => classifier (ocarina_drivers_ip_pohic::spg_sockets_init);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::pohi.c));
  end generic_sockets_ip.pohic;

  device implementation generic_sockets_ip.pohiada
  properties
    Deployment::Driver_Name       => "socketsnew";
    Implemented_As => classifier (TCP_IP_Protocol::Driver_TCP_IP_Protocol.impl);
    Device_Driver => classifier (TCP_IP_Protocol::Driver_TCP_IP_Protocol.impl);
    Initialize_Entrypoint => classifier (TCP_IP_Protocol::Initialize);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::pohi.c));
  end generic_sockets_ip.pohiada;

  ------------------
  -- RTEMS NE2000 --
  ------------------

  device rtems_ne2000
  features
    link : requires bus access ocarina_buses::ip.i;
  end rtems_ne2000;

  device implementation rtems_ne2000.ip_pohic
  properties
    Deployment::Driver_Name       => "rtems_ne2000_sockets";
    Device_Driver                 => classifier (ocarina_drivers_rtems_ne2000::driver.i);
    Initialize_Entrypoint         => classifier (ocarina_drivers_rtems_ne2000::init);
    Provided_Virtual_Bus_Class    => (classifier (ocarina_buses::pohi.c));
  end rtems_ne2000.ip_pohic;

  ------------------------------------------
  --            Exarm UDP driver          --
  ------------------------------------------
  --  This driver is used to communicate  --
  --  with the exarm robot and also       --
  --  the Matlab simulator.               --
  ------------------------------------------

  device exarm_ip
  features
    link : requires bus access ocarina_buses::ip.i;
  end exarm_ip;

  device implementation exarm_ip.vr_udp
  properties
    Deployment::Driver_Name    => "exarm";
    Device_Driver              => classifier (ocarina_drivers_udp_exarm::driver.i);
    Initialize_Entrypoint      => classifier (ocarina_drivers_udp_exarm::init);
  end exarm_ip.vr_udp;

  data exarm_protocol_data
  end exarm_protocol_data;

  data implementation exarm_protocol_data.vr extends ocarina_drivers_udp_exarm::protocol.vr
  properties
    Data_Model::Data_Representation => Struct;
  end exarm_protocol_data.vr;

  data implementation exarm_protocol_data.robot extends ocarina_drivers_udp_exarm::protocol.robot
  properties
    Data_Model::Data_Representation => Struct;
  end exarm_protocol_data.robot;

  ---------------------------------------
  --   Devices for the Exo skeleton    --
  --  National Instruments PCI-6071E   --
  ---------------------------------------
  --  This device is used to make data --
  --  acquisition of the EXARM robot.  --
  ---------------------------------------

  device exarm_ni_6071e_analog
  features
    data1  : out data port Base_Types::Float_64;
    data2  : out data port Base_Types::Float_64;
    data3  : out data port Base_Types::Float_64;
    data4  : out data port Base_Types::Float_64;
    data5  : out data port Base_Types::Float_64;
    data6  : out data port Base_Types::Float_64;
    data7  : out data port Base_Types::Float_64;
    data8  : out data port Base_Types::Float_64;
    data9  : out data port Base_Types::Float_64;
    data10 : out data port Base_Types::Float_64;
    data11 : out data port Base_Types::Float_64;
    data12 : out data port Base_Types::Float_64;
    data13 : out data port Base_Types::Float_64;
    data14 : out data port Base_Types::Float_64;
    data15 : out data port Base_Types::Float_64;
    data16 : out data port Base_Types::Float_64;
  end exarm_ni_6071e_analog;

  device implementation exarm_ni_6071e_analog.i
  properties
    Deployment::Driver_Name    => "exarm_ni_6071e_analog";
    Device_Driver              => classifier (ocarina_drivers_exarm_ni_6071e_analog::driver.i);
    Initialize_Entrypoint      => classifier (ocarina_drivers_exarm_ni_6071e_analog::spg_init);
  end exarm_ni_6071e_analog.i;

  device exarm_ni_6071e_digital
  features
    data1  : out data port Base_Types::Unsigned_8;
    data2  : out data port Base_Types::Unsigned_8;
  end exarm_ni_6071e_digital;

  device implementation exarm_ni_6071e_digital.i
  properties
    Deployment::Driver_Name    => "exarm_ni_6071e_digital";
    Device_Driver              => classifier (ocarina_drivers_exarm_ni_6071e_digital::driver.i);
    Initialize_Entrypoint      => classifier (ocarina_drivers_exarm_ni_6071e_digital::spg_init);
  end exarm_ni_6071e_digital.i;

end ocarina_drivers;

package ocarina_types

public

with Data_Model;

data integer
end integer;

data implementation integer.i
properties
   Data_Model::Data_Representation => integer;
end integer.i;

data float
end float;

data implementation float.i
properties
   Data_Model::Data_Representation => float;
end float.i;

data boolean
end boolean;

data implementation boolean.i
properties
   Data_Model::Data_Representation => boolean;
end boolean.i;

end ocarina_types;
package ocarina_drivers_exarm_ni_6071e_analog

public

with Base_Types;
with Deployment;

subprogram spg_init
properties
   Source_Language   => (C);
   Source_Name       => "__po_hi_c_driver_exarm_ni_6071e_analog_init";
end spg_init;


subprogram spg_poller
features
   data1  : out parameter Base_Types::Float_64;
   data2  : out parameter Base_Types::Float_64;
   data3  : out parameter Base_Types::Float_64;
   data4  : out parameter Base_Types::Float_64;
   data5  : out parameter Base_Types::Float_64;
   data6  : out parameter Base_Types::Float_64;
   data7  : out parameter Base_Types::Float_64;
   data8  : out parameter Base_Types::Float_64;
   data9  : out parameter Base_Types::Float_64;
   data10 : out parameter Base_Types::Float_64;
   data11 : out parameter Base_Types::Float_64;
   data12 : out parameter Base_Types::Float_64;
   data13 : out parameter Base_Types::Float_64;
   data14 : out parameter Base_Types::Float_64;
   data15 : out parameter Base_Types::Float_64;
   data16 : out parameter Base_Types::Float_64;
properties
   Source_Language   => (C);
   Source_Name       => "__po_hi_c_driver_exarm_ni_6071e_analog_poller";
end spg_poller;


thread thr_poller
features
   data1  : out data port Base_Types::Float_64;
   data2  : out data port Base_Types::Float_64;
   data3  : out data port Base_Types::Float_64;
   data4  : out data port Base_Types::Float_64;
   data5  : out data port Base_Types::Float_64;
   data6  : out data port Base_Types::Float_64;
   data7  : out data port Base_Types::Float_64;
   data8  : out data port Base_Types::Float_64;
   data9  : out data port Base_Types::Float_64;
   data10 : out data port Base_Types::Float_64;
   data11 : out data port Base_Types::Float_64;
   data12 : out data port Base_Types::Float_64;
   data13 : out data port Base_Types::Float_64;
   data14 : out data port Base_Types::Float_64;
   data15 : out data port Base_Types::Float_64;
   data16 : out data port Base_Types::Float_64;
end thr_poller;

thread implementation thr_poller.i
calls
	mycall : {
	  pspg : subprogram spg_poller;
	};
connections
   parameter pspg.data1 -> data1;   
   parameter pspg.data2 -> data2;   
   parameter pspg.data3 -> data3;   
   parameter pspg.data4 -> data4;   
   parameter pspg.data5 -> data5;   
   parameter pspg.data6 -> data6;   
   parameter pspg.data7 -> data7;   
   parameter pspg.data8 -> data8;   
   parameter pspg.data9 -> data9;   
   parameter pspg.data10 -> data10;   
   parameter pspg.data11 -> data11;   
   parameter pspg.data12 -> data12;   
   parameter pspg.data13 -> data13;   
   parameter pspg.data14 -> data14;   
   parameter pspg.data15 -> data15;   
   parameter pspg.data16 -> data16; 
properties
   Period => 100 ms;
   Dispatch_Protocol => Periodic;
end thr_poller.i;


abstract driver
features
   data1  : out data port Base_Types::Float_64;
   data2  : out data port Base_Types::Float_64;
   data3  : out data port Base_Types::Float_64;
   data4  : out data port Base_Types::Float_64;
   data5  : out data port Base_Types::Float_64;
   data6  : out data port Base_Types::Float_64;
   data7  : out data port Base_Types::Float_64;
   data8  : out data port Base_Types::Float_64;
   data9  : out data port Base_Types::Float_64;
   data10 : out data port Base_Types::Float_64;
   data11 : out data port Base_Types::Float_64;
   data12 : out data port Base_Types::Float_64;
   data13 : out data port Base_Types::Float_64;
   data14 : out data port Base_Types::Float_64;
   data15 : out data port Base_Types::Float_64;
   data16 : out data port Base_Types::Float_64;
end driver;

abstract implementation driver.i
subcomponents
   ni6071e_analog_poller : thread thr_poller.i;
connections
   port ni6071e_analog_poller.data1 -> data1;   
   port ni6071e_analog_poller.data2 -> data2;   
   port ni6071e_analog_poller.data3 -> data3;   
   port ni6071e_analog_poller.data4 -> data4;   
   port ni6071e_analog_poller.data5 -> data5;   
   port ni6071e_analog_poller.data6 -> data6;   
   port ni6071e_analog_poller.data7 -> data7;   
   port ni6071e_analog_poller.data8 -> data8;   
   port ni6071e_analog_poller.data9 -> data9;   
   port ni6071e_analog_poller.data10 -> data10;   
   port ni6071e_analog_poller.data11 -> data11;   
   port ni6071e_analog_poller.data12 -> data12;   
   port ni6071e_analog_poller.data13 -> data13;   
   port ni6071e_analog_poller.data14 -> data14;   
   port ni6071e_analog_poller.data15 -> data15;   
   port ni6071e_analog_poller.data16 -> data16; 
end driver.i;

end ocarina_drivers_exarm_ni_6071e_analog;
package ocarina_drivers_exarm_ni_6071e_digital

public

with Base_Types;
with Deployment;

subprogram spg_init
properties
   Source_Language   => (C);
   Source_Name       => "__po_hi_c_driver_exarm_ni_6071e_digital_init";
end spg_init;


subprogram spg_poller
features
   data1 : out parameter Base_Types::Unsigned_32;
   data2 : out parameter Base_Types::Unsigned_32;
properties
   Source_Language   => (C);
   Source_Name       => "__po_hi_c_driver_exarm_ni_6071e_digital_poller";
end spg_poller;


thread thr_poller
features
   data1 : out data port Base_Types::Unsigned_32;
   data2 : out data port Base_Types::Unsigned_32;
end thr_poller;

thread implementation thr_poller.i
calls
	mycall : {
	  pspg : subprogram spg_poller;
	};
connections
   parameter pspg.data1 -> data1;   
   parameter pspg.data2 -> data2;   
properties
   Period => 100 ms;
   Dispatch_Protocol => Periodic;
end thr_poller.i;


abstract driver
features
   data1 : out data port Base_Types::Unsigned_32;
   data2 : out data port Base_Types::Unsigned_32;
properties
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
end driver;

abstract implementation driver.i
subcomponents
   ni6071e_digital_poller : thread thr_poller.i;
connections
   port ni6071e_digital_poller.data1 -> data1; 
   port ni6071e_digital_poller.data2 -> data2; 
end driver.i;

end ocarina_drivers_exarm_ni_6071e_digital;
package ocarina_drivers_generic_keyboard

public

with Base_Types;
with Deployment;

subprogram spg_generic_keyboard_init
properties
	Source_Language   => (C);
	Source_Name       => "__po_hi_driver_generic_keyboard_init";
end spg_generic_keyboard_init;


thread keyboard_poller
features
   key_pressed : out data port Base_Types::Integer;
end keyboard_poller;

thread implementation keyboard_poller.i
calls
	mycall : {
	  pspg : subprogram spg_generic_keyboard_poller;
	};
connections
   parameter pspg.key_pressed -> key_pressed;
properties
   Period => 100ms;
   Dispatch_Protocol => Periodic;
end keyboard_poller.i;


subprogram spg_generic_keyboard_poller
features
   key_pressed : out parameter Base_Types::Integer;
properties
	Source_Language   => (C);
	Source_Name       => "__po_hi_driver_generic_keyboard_poller";
end spg_generic_keyboard_poller;

abstract generic_keyboard_driver
features
   key_pressed : out data port Base_Types::Integer;
properties
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
end generic_keyboard_driver;


abstract implementation generic_keyboard_driver.i
subcomponents
   keyboard_receiver : thread       keyboard_poller.i;
connections
   port keyboard_receiver.key_pressed -> key_pressed;
end generic_keyboard_driver.i;


end ocarina_drivers_generic_keyboard;
package Generic_Bus
public

  ---------
  -- BUS --
  ---------

  -- Generic bus to model connections between processors and
  -- devices. It is not used by the code generation process, so it is
  -- made fully generic.

  bus Generic_Bus
  end Generic_Bus;

  bus implementation Generic_Bus.impl
  end Generic_Bus.impl;

end Generic_Bus;
package Generic_Native

-- This package models a generic native platform with one generic bus. 
--
-- Native platforms are GNU/Linux variants, MacOS X, Solaris, Windows,
-- ...

public
  with Deployment;
  with Generic_Bus;

  ---------------
  -- PROCESSOR --
  ---------------

  -- Generic_Processor is the basic description of a processor with
  -- one bus to connect an ethernet adapter. This ethernet adapter is
  -- used through the TCP_IP_Device defined in TCP_IP_Protocol
  -- package.

  processor Generic_Processor
  features
    eth0_tcp_ip : requires bus access Generic_Bus::Generic_Bus.impl;
    -- One ethernet card, connected to the processor. It is assumed
    -- later that it is used through a TCP/IP stack

  end Generic_Processor;

  ------------
  -- MEMORY --
  ------------

  memory Memory_Segment
  end Memory_Segment;

  memory implementation Memory_Segment.impl
  end Memory_Segment.impl;

end Generic_Native;
package GR_CPCI_X4CV

-- This package models the GR-Rasta GR-CPCI-XC4V LEON Compact-PCI
-- Development board by AEROFlex Gaisler.

public
  with Deployment;
  with Generic_Bus;
  
  ---------------
  -- PROCESSOR --
  ---------------

  -- The Rasta board has one LEON2 processor, 3 SpW cores and several
  -- UARTS.  
  -- 
  -- SpaceWire cores and UARTS are connected to separate bus, of type
  -- Generic_Bus.impl.

  processor LEON2
  features
    spw_core_1 : requires bus access Generic_Bus::Generic_Bus.impl;
    spw_core_2 : requires bus access Generic_Bus::Generic_Bus.impl;
    spw_core_3 : requires bus access Generic_Bus::Generic_Bus.impl;
    -- Three SpaceWire cores

    -- XXX Add UARTS
  end LEON2;

  ------------
  -- MEMORY --
  ------------

  memory Memory_Segment
  end Memory_Segment;

  memory implementation Memory_Segment.impl
  end Memory_Segment.impl;

end GR_CPCI_X4CV;
package GRSPW

-- This package models a SpaceWire-based protocol layer for the
-- PolyORB-HI/Ada AADL runtime, based on the GRSPW chipset from
-- AEROFlex Gaisler. It defines the subprograms and threads to be
-- integrated with the runtime low level interface.
--
-- To configure this interface, you should use the
-- Deployment::Configuration property with the following format:
--     "spacewire Sender_Core_id Receiver_Core_Id"
--
-- e.g.
--
--     spw : device GRSPW::GRSPW_Device
--            {Deployment::Configuration => "spacewire 1 2"};
--

public

   with Deployment;
   with GR_CPCI_X4CV;
   with Generic_Bus;

   ------------
   -- DEVICE --
   ------------

   -- The main entrypoint for this package is this device, it relies
   -- on the 'Implement_As' feature that defines its full
   -- specification.

   device GRSPW_Device
   features
      LVDS_Wire : requires bus access Generic_Bus::Generic_Bus.impl;
      -- Connection to the remote node

   end GRSPW_Device;

   device implementation GRSPW_Device.impl
   properties
      Implemented_As =>
         classifier (GRSPW::Driver_GRSPW_Protocol.impl);
      Initialize_Entrypoint => classifier (GRSPW::Initialize);
   end GRSPW_Device.impl;

   ------------
   -- DRIVER --
   ------------

   -- In AADLv2, we can model the actual implementation of a driver
   -- using an abstract component.

   abstract Driver_GRSPW_Protocol
   properties
      Deployment::Version  => "0.1beta";
      Deployment::Help     => "Write your ASN.1 configuration here";
      Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_spacewire);
   end Driver_GRSPW_Protocol;

   abstract implementation Driver_GRSPW_Protocol.impl
   subcomponents
      receiver : thread Driver_GRSPW_Protocol_thread_receiver.impl;
      sender : subprogram Send;
   end Driver_GRSPW_Protocol.impl;

   -------------
   -- THREADS --
   -------------

   -- This thread handles the execution logic of the protocol
   -- stack. It relies on the previous subprograms to receive
   -- messages.

   thread Driver_GRSPW_Protocol_thread_receiver

      -- This thread is dispatched when an event is detected on the
      -- real hardware. It then calls receive to handle the incoming
      -- event.

   properties
      Dispatch_Protocol => Background;
      Priority          => 12;
   end Driver_GRSPW_Protocol_thread_receiver;

   thread implementation Driver_GRSPW_Protocol_thread_receiver.impl
   calls
      call1 : { pspg : subprogram receive; };
   end Driver_GRSPW_Protocol_thread_receiver.impl;

   -----------------
   -- SUBPROGRAMS --
   -----------------

   -- These subprograms model the high-level view of the SpaceWire
   -- protocol stack. They define an API used by the stack to send and
   -- receive data, and perform node's initialisation.

   subprogram Initialize

     -- Initialize the different internal resources for managing
     -- connections on a node. This subprogram has no formal visible
     -- parameters, but relies on well-known data structures and
     -- variables to configure the stack.

   properties
      Source_Name => "PolyORB_HI_Drivers_GRSPW.Initialize";
      Source_Language => (Ada);
   end Initialize;

   -------------

   subprogram Receive

      -- Receive data and dispatch them to the receiving entity. This
      -- program and its sibling (send) share a common protocol, not
      -- defined in the AADL model.

   properties
      Source_Name => "PolyORB_HI_Drivers_GRSPW.Receive";
      Source_Language => (Ada);
   end Receive;

   -------------

   subprogram Send

      -- Send data to a remote node. This program and its sibling
      -- (receive) share a common protocol, not defined in the AADL
      -- model.

   properties
      Source_Name => "PolyORB_HI_Drivers_GRSPW.Send";
      Source_Language => (Ada);
   end Send;

end GRSPW;
package GRUART

-- This package models a UART-based protocol layer for the
-- PolyORB-HI/Ada AADL runtime, based on the GRUART chipset from
-- AEROFlex Gaisler. It defines the subprograms and threads to be
-- integrated with the runtime low level interface.
--
-- To configure this interface, you should use the
-- Deployment::Configuration property with the following format:
--     "serial DEVICE BAUDS DATA_BITS PARITY STOP_BIT"
--
-- e.g.
--
--     uart : device GRUART::GRUART_Device
--            {Deployment::Configuration => "serial /dev/ttyS0 9600 8 N 1"
--

public

   with Deployment;
   with GR_CPCI_X4CV;
   with Generic_Bus;

   ------------
   -- DEVICE --
   ------------

   -- The main entrypoint for this package is this device, it relies
   -- on the 'Implement_As' feature that defines its full
   -- specification.

   device GRUART_Device
   features
      DB9_Wire : requires bus access Generic_Bus::Generic_Bus.impl;
      -- Connection to the remote node

   end GRUART_Device;

   device implementation GRUART_Device.impl
   properties
      Implemented_As =>
         classifier (GRUART::Driver_GRUART_Protocol.impl);
      Initialize_Entrypoint => classifier (GRUART::Initialize);
   end GRUART_Device.impl;

   ------------
   -- DRIVER --
   ------------

   -- In AADLv2, we can model the actual implementation of a driver
   -- using an abstract component.

   abstract Driver_GRUART_Protocol
   properties
      Deployment::Configuration_Type
        => classifier (ocarina_drivers::configuration_type_serial);
      Deployment::Version  => "0.1beta";
      Deployment::Help     => "Write your ASN.1 configuration here";
   end Driver_GRUART_Protocol;

   abstract implementation Driver_GRUART_Protocol.impl
   subcomponents
      receiver : thread Driver_GRUART_Protocol_thread_receiver.impl;
      sender : subprogram Send;
   end Driver_GRUART_Protocol.impl;

   -------------
   -- THREADS --
   -------------

   -- This thread handles the execution logic of the protocol
   -- stack. It relies on the previous subprograms to receive
   -- messages.

   thread Driver_GRUART_Protocol_thread_receiver

      -- This thread is dispatched when an event is detected on the
      -- real hardware. It then calls receive to handle the incoming
      -- event.

   properties
      Dispatch_Protocol => Background;
      Priority          => 10;
      source_stack_size => 200 KByte;
   end Driver_GRUART_Protocol_thread_receiver;

   thread implementation Driver_GRUART_Protocol_thread_receiver.impl
   calls
      call1 : { pspg : subprogram receive; };
   end Driver_GRUART_Protocol_thread_receiver.impl;

   -----------------
   -- SUBPROGRAMS --
   -----------------

   -- These subprograms model the high-level view of the SpaceWire
   -- protocol stack. They define an API used by the stack to send and
   -- receive data, and perform node's initialisation.

   subprogram Initialize

     -- Initialize the different internal resources for managing
     -- connections on a node. This subprogram has no formal visible
     -- parameters, but relies on well-known data structures and
     -- variables to configure the stack.

   properties
      Source_Name => "PolyORB_HI_Drivers_GRUART.Initialize";
      Source_Language => (Ada);
   end Initialize;

   -------------

   subprogram Receive

      -- Receive data and dispatch them to the receiving entity. This
      -- program and its sibling (send) share a common protocol, not
      -- defined in the AADL model.

   properties
      Source_Name => "PolyORB_HI_Drivers_GRUART.Receive";
      Source_Language => (Ada);
   end Receive;

   -------------

   subprogram Send

      -- Send data to a remote node. This program and its sibling
      -- (receive) share a common protocol, not defined in the AADL
      -- model.

   properties
      Source_Name => "PolyORB_HI_Drivers_GRUART.Send";
      Source_Language => (Ada);
   end Send;

end GRUART;
package ocarina_drivers_leon_eth

public

with Deployment;
with ocarina_buses;
with ocarina_drivers;

subprogram spg_leon_eth_poller
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_eth_leon_poller";
end spg_leon_eth_poller;


subprogram spg_leon_eth_sender
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_eth_leon_sender";
end spg_leon_eth_sender;

subprogram spg_leon_eth_init
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_eth_leon_init";
end spg_leon_eth_init;

thread thr_poller
end thr_poller;


thread implementation thr_poller.i
calls
	mycall : {
	  pspg : subprogram spg_leon_eth_poller;
	};
properties
   Period => 1000ms;
   Dispatch_Protocol => Periodic;
end thr_poller.i;

abstract eth_driver
properties
   Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_ip);
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
end eth_driver;

abstract implementation eth_driver.leon
subcomponents
   sender                : subprogram spg_leon_eth_sender;
end eth_driver.leon;

abstract implementation eth_driver.leon_sender
subcomponents
   sender                : subprogram spg_leon_eth_sender;
end eth_driver.leon_sender;


end ocarina_drivers_leon_eth;
package ocarina_drivers_leon_serial

public

with Deployment;
with ocarina_buses;
with ocarina_drivers;

subprogram spg_serial_poller_leon
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_serial_leon_poller";
end spg_serial_poller_leon;


subprogram spg_serial_sender_leon
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_serial_leon_sender";
end spg_serial_sender_leon;

subprogram spg_serial_init_leon
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_serial_leon_init";
end spg_serial_init_leon;

subprogram spg_serial_init_leon_sender
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_serial_leon_init_sender";
end spg_serial_init_leon_sender;

thread serial_poller
end serial_poller;


thread implementation serial_poller.leon
calls
	mycall : {
	  pspg : subprogram spg_serial_poller_leon;
	};
properties
   Period => 1000ms;
   Dispatch_Protocol => Periodic;
end serial_poller.leon;

abstract serial_driver
properties
   Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_serial);
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
end serial_driver;

abstract implementation serial_driver.leon
subcomponents
   receiver_leon_serial  : thread serial_poller.leon;
   sender                : subprogram spg_serial_sender_leon;
end serial_driver.leon;

abstract implementation serial_driver.leon_sender
subcomponents
   sender                : subprogram spg_serial_sender_leon;
end serial_driver.leon_sender;


end ocarina_drivers_leon_serial;
package Native_UART

-- This package models a UART protocol layer for the PolyORB-HI/Ada
-- AADL runtime. It defines the subprograms and threads to be
-- integrated with the runtime low level interface.
--
-- To configure this interface, you should use the
-- Deployment::Configuration property with the following format:
--     "serial DEVICE BAUDS DATA_BITS PARITY STOP_BIT"
--
-- e.g.
--
--     uart : device GRUART::GRUART_Device
--            {Deployment::Configuration => "serial /dev/ttyS0 9600 8 N 1"
--

public

   with Deployment;
   with Generic_Bus;

   ------------
   -- DEVICE --
   ------------

   -- The main entrypoint for this package is this device, it relies
   -- on the 'Implement_As' feature that defines its full
   -- specification.

   device Native_UART_Device
   features
      DB9_Wire : requires bus access Generic_Bus::Generic_Bus.impl;
      -- Connection to the remote node

   end Native_UART_Device;

   device implementation Native_UART_Device.impl
   properties
      Implemented_As =>
         classifier (Native_UART::Driver_Native_UART_Protocol.impl);
      Initialize_Entrypoint => classifier (Native_UART::Initialize);
   end Native_UART_Device.impl;

   ------------
   -- DRIVER --
   ------------

   -- In AADLv2, we can model the actual implementation of a driver
   -- using an abstract component.

   abstract Driver_Native_UART_Protocol
   properties
      Deployment::Configuration_Type
        => classifier (ocarina_drivers::configuration_type_serial);
      Deployment::Version  => "0.1beta";
      Deployment::Help     => "Write your ASN.1 configuration here";
   end Driver_Native_UART_Protocol;

   abstract implementation Driver_Native_UART_Protocol.impl
   subcomponents
      receiver : thread Driver_Native_UART_Protocol_thread_receiver.impl;
      sender : subprogram Send;
   end Driver_Native_UART_Protocol.impl;

   -------------
   -- THREADS --
   -------------

   -- This thread handles the execution logic of the protocol
   -- stack. It relies on the previous subprograms to receive
   -- messages.

   thread Driver_Native_UART_Protocol_thread_receiver

      -- This thread is dispatched when an event is detected on the
      -- real hardware. It then calls receive to handle the incoming
      -- event.

   properties
      Dispatch_Protocol => Background;
      Priority          => 10;
      source_stack_size => 200 KByte;
   end Driver_Native_UART_Protocol_thread_receiver;

   thread implementation Driver_Native_UART_Protocol_thread_receiver.impl
   calls
      call1 : { pspg : subprogram receive; };
   end Driver_Native_UART_Protocol_thread_receiver.impl;

   -----------------
   -- SUBPROGRAMS --
   -----------------

   -- These subprograms model the high-level view of the SpaceWire
   -- protocol stack. They define an API used by the stack to send and
   -- receive data, and perform node's initialisation.

   subprogram Initialize

     -- Initialize the different internal resources for managing
     -- connections on a node. This subprogram has no formal visible
     -- parameters, but relies on well-known data structures and
     -- variables to configure the stack.

   properties
      Source_Name => "PolyORB_HI_Drivers_Native_UART.Initialize";
      Source_Language => (Ada);
   end Initialize;

   -------------

   subprogram Receive

      -- Receive data and dispatch them to the receiving entity. This
      -- program and its sibling (send) share a common protocol, not
      -- defined in the AADL model.

   properties
      Source_Name => "PolyORB_HI_Drivers_Native_UART.Receive";
      Source_Language => (Ada);
   end Receive;

   -------------

   subprogram Send

      -- Send data to a remote node. This program and its sibling
      -- (receive) share a common protocol, not defined in the AADL
      -- model.

   properties
      Source_Name => "PolyORB_HI_Drivers_Native_UART.Send";
      Source_Language => (Ada);
   end Send;

end Native_UART;
package ocarina_drivers_rasta_1553

public
with Deployment;

subprogram spg_1553_controller_rasta
properties
	Source_Language   => (C);
	Source_Name       => "__po_hi_c_driver_1553_rasta_controller";
end spg_1553_controller_rasta;

subprogram spg_1553_poller_rasta_terminal
properties
	Source_Language   => (C);
	Source_Name       => "__po_hi_c_driver_1553_rasta_terminal_poller";
end spg_1553_poller_rasta_terminal;

subprogram spg_1553_sender_rasta_controller
properties
	Source_Language   => (C);
	Source_Name       => "__po_hi_c_driver_1553_rasta_sender_controller";
end spg_1553_sender_rasta_controller;

subprogram spg_1553_sender_rasta_terminal
properties
	Source_Language   => (C);
	Source_Name       => "__po_hi_c_driver_1553_rasta_sender_terminal";
end spg_1553_sender_rasta_terminal;


subprogram spg_1553_init_rasta_controller
properties
	Source_Language   => (C);
	Source_Name       => "__po_hi_c_driver_1553_rasta_init_controller";
end spg_1553_init_rasta_controller;


subprogram spg_1553_init_rasta_terminal
properties
	Source_Language   => (C);
	Source_Name       => "__po_hi_c_driver_1553_rasta_init_terminal";
end spg_1553_init_rasta_terminal;



thread if1553_poller
end if1553_poller;

thread implementation if1553_poller.rasta_terminal
calls
	mycall : {
	  pspg : subprogram spg_1553_poller_rasta_terminal;
	};
properties
   Period => 2000ms;
   Dispatch_Protocol => Periodic;
end if1553_poller.rasta_terminal;

thread if1553_controller
end if1553_controller;

thread implementation if1553_controller.rasta
calls
	mycall : {
	  pspg : subprogram spg_1553_controller_rasta;
	};
properties
   Period => 4000ms;
   Dispatch_Protocol => Periodic;
end if1553_controller.rasta;



abstract if1553_driver
properties
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
end if1553_driver;

abstract implementation if1553_driver.rasta_terminal
subcomponents
   receiver_rasta_1553 : thread       if1553_poller.rasta_terminal;
   sender              : subprogram   spg_1553_sender_rasta_terminal;
end if1553_driver.rasta_terminal;

abstract implementation if1553_driver.rasta_controller_sender_only
subcomponents
--   controller  : thread       if1553_controller.rasta;
--   This thread (controller) should be a poller thread that
--   gives orders to the terminal nodes to send/receive data.
--   It should also specify the communication policy (when a terminal
--   is authorized to send/receive data).

--   We don't specify poller and receiver since this controller
--   is just a node that sends data to a single other node.

   sender      : subprogram   spg_1553_sender_rasta_controller;
end if1553_driver.rasta_controller_sender_only;


end ocarina_drivers_rasta_1553;
package ocarina_drivers_rasta_serial

public

with Deployment;
with ocarina_buses;
with ocarina_drivers;

subprogram spg_serial_poller_rasta
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_serial_rasta_poller";
end spg_serial_poller_rasta;


subprogram spg_serial_sender_rasta
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_serial_rasta_sender";
end spg_serial_sender_rasta;




subprogram spg_serial_init_rasta
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_serial_rasta_init";
end spg_serial_init_rasta;


thread serial_poller
end serial_poller;


thread implementation serial_poller.rasta
calls
	mycall : {
	  pspg : subprogram spg_serial_poller_rasta;
	};
properties
   Period => 1000ms;
   Dispatch_Protocol => Periodic;
end serial_poller.rasta;

abstract serial_driver
properties
   Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_serial);
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
end serial_driver;

abstract implementation serial_driver.rasta
subcomponents
   receiver_rasta_serial : thread serial_poller.rasta;
   sender                : subprogram spg_serial_sender_rasta;
end serial_driver.rasta;

end ocarina_drivers_rasta_serial;
package ocarina_drivers_rasta_spacewire

public

with ocarina_buses;
with Deployment;

subprogram spg_spacewire_poller_rasta
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_spacewire_rasta_poller";
end spg_spacewire_poller_rasta;

subprogram spg_spacewire_sender_rasta
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_spacewire_rasta_sender";
end spg_spacewire_sender_rasta;

subprogram spg_spacewire_init_rasta
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_spacewire_rasta_init";
end spg_spacewire_init_rasta;


thread spacewire_poller
end spacewire_poller;

thread implementation spacewire_poller.rasta
calls
	mycall : {
	  pspg : subprogram spg_spacewire_poller_rasta;
	};
properties
   Period => 1000ms;
   Dispatch_Protocol => Periodic;
end spacewire_poller.rasta;


abstract spacewire_driver
properties
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
   Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_spacewire);
end spacewire_driver;

abstract implementation spacewire_driver.rasta
subcomponents
   receiver_rasta_spacewire : thread spacewire_poller.rasta;
   sender                   : subprogram spg_spacewire_sender_rasta;
end spacewire_driver.rasta;

end ocarina_drivers_rasta_spacewire;
package ocarina_drivers_scoc3_spacewire

public

with ocarina_buses;
with Deployment;

subprogram spg_poller
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_spacewire_scoc3_poller";
end spg_poller;

subprogram spg_sender
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_spacewire_scoc3_sender";
end spg_sender;

subprogram spg_init
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_spacewire_scoc3_init";
end spg_init;


thread thr_poller
end thr_poller;

thread implementation thr_poller.i
calls
	mycall : {
	  pspg : subprogram spg_poller;
	};
properties
   Period => 1000ms;
   Dispatch_Protocol => Periodic;
end thr_poller.i;


abstract driver
properties
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Check the ASN.1 type definition";
   Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_spacewire);
end driver;

abstract implementation driver.i
subcomponents
   receiver_rasta_spacewire : thread thr_poller.i;
   sender                   : subprogram spg_sender;
end driver.i;

end ocarina_drivers_scoc3_spacewire;
package ocarina_drivers_star_dundee_spacewire_brick
public

with ocarina_buses;
with Deployment;

subprogram spg_poller
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_spw_usb_brick_poller";
end spg_poller;

subprogram spg_sender
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_spw_usb_brick_sender";
end spg_sender;

subprogram spg_init
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_spw_usb_brick_init";
end spg_init;


thread thr_poller
end thr_poller;

thread implementation thr_poller.i
calls
	mycall : {
	  pspg : subprogram spg_poller;
	};
properties
   Period => 1000ms;
   Dispatch_Protocol => Periodic;
end thr_poller.i;


abstract driver
properties
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
   Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_spacewire);
end driver;

abstract implementation driver.usb_brick
subcomponents
   receiver_rasta_spacewire : thread thr_poller.i;
   sender                   : subprogram spg_sender;
end driver.usb_brick;

end ocarina_drivers_star_dundee_spacewire_brick;
package ocarina_drivers_serial

public

with Deployment;
with ocarina_drivers;

subprogram spg_serial_poller_linux
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_serial_linux_poller";
end spg_serial_poller_linux;


subprogram spg_serial_sender_linux
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_serial_linux_sender";
end spg_serial_sender_linux;


subprogram spg_serial_init_linux
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_serial_linux_init";
end spg_serial_init_linux;

subprogram spg_serial_init_linux_sender
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_serial_linux_init_sender";
end spg_serial_init_linux_sender;

subprogram spg_serial_init_linux_receiver
properties
	Source_Language => (C);
	Source_Name => "__po_hi_c_driver_serial_linux_init_receiver";
end spg_serial_init_linux_receiver;

thread serial_poller
end serial_poller;

thread implementation serial_poller.linux
calls
	mycall : {
	  pspg : subprogram spg_serial_poller_linux;
	};
properties
   Period => 1000ms;
   Dispatch_Protocol => Periodic;
end serial_poller.linux;


abstract serial_driver
properties
   Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_serial);
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
end serial_driver;

abstract implementation serial_driver.linux
subcomponents
   serial_linux_receiver : thread serial_poller.linux;
   sender                : subprogram spg_serial_sender_linux;
end serial_driver.linux;

abstract implementation serial_driver.linux_sender
subcomponents
   sender                : subprogram spg_serial_sender_linux;
end serial_driver.linux_sender;


abstract implementation serial_driver.linux_receiver
subcomponents
   serial_linux_receiver : thread serial_poller.linux;
end serial_driver.linux_receiver;

end ocarina_drivers_serial;
package ocarina_drivers_ip_pohic

public
with Deployment;
with ocarina_drivers;

subprogram spg_sockets_init
properties
	Source_Language   => (C);
	Source_Name       => "__po_hi_driver_sockets_init";
end spg_sockets_init;


subprogram spg_eth_linux_sender
properties
	Source_Language   => (C);
	Source_Name       => "__po_hi_driver_sockets_send";
end spg_eth_linux_sender;

subprogram implementation spg_eth_linux_sender.i
end spg_eth_linux_sender.i;

abstract sockets_impl
properties
   Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_ip);
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
end sockets_impl;

abstract implementation sockets_impl.i
subcomponents
   sender   : subprogram   spg_eth_linux_sender.i;
end sockets_impl.i;

end ocarina_drivers_ip_pohic;
package ocarina_drivers_rtems_ne2000

public

with Deployment;

subprogram init
properties
	Source_Language   => (C);
	Source_Name       => "__po_hi_driver_rtems_ne2000_init";
end init;

thread poller
end poller;

thread implementation poller.i
calls
	mycall : {
	  pspg : subprogram spg_poller;
	};
properties
   Period => 1000ms;
   Dispatch_Protocol => Periodic;
end poller.i;


subprogram spg_poller
properties
	Source_Language   => (C);
	Source_Name       => "__po_hi_driver_rtems_ne2000_poller";
end spg_poller;


subprogram spg_sender
properties
	Source_Language   => (C);
	Source_Name       => "__po_hi_driver_sockets_send";
end spg_sender;


abstract driver
properties
   Deployment::Version  => "0.1beta";
   Deployment::Help     => "Write your ASN.1 configuration here";
end driver;


abstract implementation driver.i
subcomponents
--  receiver : thread       eth_sockets_ne2000_rtems_poller.i;
   sender   : subprogram   spg_sender;
end driver.i;

end ocarina_drivers_rtems_ne2000;
package TCP_IP_Protocol

-- This package models a TCP/IP based protocol layer for the
-- PolyORB-HI/Ada AADL runtime. It defines the subprograms and threads
-- to be integrated with the runtime low level interface.
--
-- To configure this interface, you should use the
-- Deployment::Configuration property with the following format:
--     "ip <ipv4_addresse> <ipv4_port>"
--
-- e.g.
--
--     netif : device TCP_IP_Protocol::TCP_IP_Device
--            {Deployment::Configuration => "ip 192.168.0.10 45678";}:

public

   with Generic_Bus;
   with Deployment;

   ------------
   -- DEVICE --
   ------------

   -- The main entrypoint for this package is this device, it relies
   -- on the 'Implement_As' feature that defines its full
   -- specification.

   device TCP_IP_Device
   features
      Ethernet_Wire : requires bus access Generic_Bus::Generic_Bus.impl;
      -- Connection to the remote node

   end TCP_IP_Device;

   device implementation TCP_IP_Device.impl
   properties
      Implemented_As =>
         classifier (TCP_IP_Protocol::Driver_TCP_IP_Protocol.impl);
      Initialize_Entrypoint => classifier (TCP_IP_Protocol::Initialize);
   end TCP_IP_Device.impl;

   ------------
   -- DRIVER --
   ------------

   -- In AADLv2, we can model the actual implementation of a driver
   -- using an abstract component.

   abstract Driver_TCP_IP_Protocol
   properties
      Deployment::Configuration_Type => classifier (ocarina_drivers::configuration_type_ip);
      Deployment::Version  => "0.1beta";
      Deployment::Help     => "Write your ASN.1 configuration here";
   end Driver_TCP_IP_Protocol;

   abstract implementation Driver_TCP_IP_Protocol.impl
   subcomponents
      receiver : thread Driver_TCP_IP_Protocol_thread_receiver.impl;
      sender : subprogram Send;
   end Driver_TCP_IP_Protocol.impl;

   -------------
   -- THREADS --
   -------------

   -- This thread handles the execution logic of the protocol
   -- stack. It relies on the previous subprograms to receive
   -- messages.

   thread Driver_TCP_IP_Protocol_thread_receiver

      -- This thread is dispatched when an event is detected on the
      -- real hardware. It then calls receive to handle the incoming
      -- event.

   properties
      -- Initialize_Entrypoint
      --    => classifier (TCP_IP_Protocol::Initialize_Receiver);
      Dispatch_Protocol => Background;
   end Driver_TCP_IP_Protocol_thread_receiver;

   thread implementation Driver_TCP_IP_Protocol_thread_receiver.impl
   calls
      call1 : { pspg : subprogram receive; };
   end Driver_TCP_IP_Protocol_thread_receiver.impl;

   -----------------
   -- SUBPROGRAMS --
   -----------------

   -- These subprograms model the high-level view of the TCP/IP
   -- protocol stack. They define an API used by the stack to send and
   -- receive data, and perform node's initialisation.

   subprogram Initialize

     -- Initialize the different internal resources for managing
     -- connections on a node. This subprogram has no formal visible
     -- parameters, but relies on well-known data structures and
     -- variables to configure the stack.

   properties
      Source_Name => "POlyORB_HI_Drivers_Native_TCP_IP.Initialize";
      Source_Language => (Ada);
   end Initialize;

   -------------

   subprogram Initialize_Receiver

     -- Initialize the receiver thread

   properties
      Source_Name => "POlyORB_HI_Drivers_Native_TCP_IP.Initialize_Receiver";
      Source_Language => (Ada);
   end Initialize_Receiver;

   -------------

   subprogram Receive

      -- Receive data and dispatch them to the receiving entity. This
      -- program and its sibling (send) share a common protocol, not
      -- defined in the AADL model.

   properties
      Source_Name => "POlyORB_HI_Drivers_Native_TCP_IP.Receive";
      Source_Language => (Ada);
   end Receive;

   -------------

   subprogram Send

      -- Send data to a remote node. This program and its sibling
      -- (receive) share a common protocol, not defined in the AADL
      -- model.

   properties
      Source_Name => "POlyORB_HI_Drivers_Native_TCP_IP.Send";
      Source_Language => (Ada);
   end Send;

end TCP_IP_Protocol;
package ocarina_drivers_udp_exarm

public

with Data_Model;
with Base_Types;

data protocol
properties
   Data_Model::Data_Representation => Struct;
end protocol;

data implementation protocol.robot
subcomponents
   cmd   : data Base_Types::Unsigned_32;
   pktid : data Base_Types::Unsigned_32;
   X1    : data Base_Types::Float_32;
   X2    : data Base_Types::Float_32;
   X3    : data Base_Types::Float_32;
   Y1    : data Base_Types::Float_32;
   Y2    : data Base_Types::Float_32;
   Y3    : data Base_Types::Float_32;
   Z1    : data Base_Types::Float_32;
   Z2    : data Base_Types::Float_32;
   Z3    : data Base_Types::Float_32;
   P1    : data Base_Types::Float_32;
   P2    : data Base_Types::Float_32;
   P3    : data Base_Types::Float_32;
   J1    : data Base_Types::Float_32;
   J2    : data Base_Types::Float_32;
   J3    : data Base_Types::Float_32;
   J4    : data Base_Types::Float_32;
   J5    : data Base_Types::Float_32;
   J6    : data Base_Types::Float_32;
   J7    : data Base_Types::Float_32;
   Elbow : data Base_Types::Float_32;
end protocol.robot;


data implementation protocol.vr
subcomponents
   J1    : data Base_Types::Float_64;
   J2    : data Base_Types::Float_64;
   J3    : data Base_Types::Float_64;
   J4    : data Base_Types::Float_64;
   J5    : data Base_Types::Float_64;
   J6    : data Base_Types::Float_64;
   J7    : data Base_Types::Float_64;
   J8    : data Base_Types::Float_64;
   J9    : data Base_Types::Float_64;
   J10    : data Base_Types::Float_64;
   J11    : data Base_Types::Float_64;
   J12    : data Base_Types::Float_64;
   J13    : data Base_Types::Float_64;
   J14    : data Base_Types::Float_64;
   J15    : data Base_Types::Float_64;
   J16    : data Base_Types::Float_64;
   P1    : data Base_Types::Float_64;
   P2    : data Base_Types::Float_64;
   P3    : data Base_Types::Float_64;
   X1    : data Base_Types::Float_64;
   X2    : data Base_Types::Float_64;
   X3    : data Base_Types::Float_64;
   Y1    : data Base_Types::Float_64;
   Y2    : data Base_Types::Float_64;
   Y3    : data Base_Types::Float_64;
   Z1    : data Base_Types::Float_64;
   Z2    : data Base_Types::Float_64;
   Z3    : data Base_Types::Float_64;
end protocol.vr;


subprogram init
properties
   Source_Language   => (C);
   Source_Name       => "__po_hi_driver_exarm_init";
end init;

subprogram spg_sender
properties
   Source_Language   => (C);
   Source_Name       => "__po_hi_driver_exarm_send";
end spg_sender;

abstract driver
end driver;

abstract implementation driver.i
subcomponents
   sender : subprogram spg_sender;
end driver.i;

end ocarina_drivers_udp_exarm;
package ocarina_processors_arm

public

with Deployment;
with Cheddar_Properties;

processor arm
end arm;

processor nds extends arm
end nds;

processor gumstix extends arm
end gumstix;

end ocarina_processors_arm;
package ocarina_processors_leon

public

with Deployment;
with ARINC653;
with Cheddar_Properties;

processor leon
end leon;

processor implementation leon.rtems_posix
properties
   Scheduling_Protocol => (Posix_1003_Highest_Priority_First_Protocol);
   Priority_Range => 0 .. 255;
   Cheddar_Properties::Scheduler_Quantum => 0 Ms;
   Cheddar_Properties::Preemptive_Scheduler => true;
   Deployment::Execution_Platform => LEON_RTEMS_POSIX;
end leon.rtems_posix;

processor leon3
end leon3;

virtual processor xtratum_partition
end xtratum_partition;

virtual processor implementation xtratum_partition.generic
end xtratum_partition.generic;

end ocarina_processors_leon;
package ocarina_processors_x86

public

with Deployment;

processor x86
properties
   Scheduling_Protocol => (RATE_MONOTONIC_PROTOCOL);
   Deployment::Execution_Platform => Native;
end x86;

processor implementation x86.linux32
properties
   Deployment::Execution_Platform => Linux32;
end x86.linux32;

processor implementation x86.win32
properties
   Deployment::Execution_Platform => win32;
end x86.win32;

processor implementation x86.xenomai_posix
properties
   Deployment::Execution_Platform => linux32_xenomai_posix;
end x86.xenomai_posix;

end ocarina_processors_x86;



