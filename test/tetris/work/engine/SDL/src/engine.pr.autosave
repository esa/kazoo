/* CIF PROCESS (250, 150), (150, 75) */
process Engine;
    /* CIF TEXT (740, 0), (255, 250) */
    -- Timers defined in the interface view
    -- Use SET_TIMER (value, timer name)
    -- and RESET_TIMER (timer name) in a
    -- PROCEDURE CALL symbol to use them
    timer Tetris_Timer;
    
    dcl foo T_Boolean;
    
    dcl Timer_Value Timer_Duration := 500;
    
    dcl Prev_Sprite, Next_Sprite Sprite;
    
    dcl cmd Move_Command;
    
    dcl Landscape, Play_Area Grid;
    /* CIF ENDTEXT */
    /* CIF procedure (151, 108), (127, 35) */
    procedure Clear_Playground;
        /* CIF TEXT (66, 127), (267, 140) */
        fpar
            in/out Playground Grid;
        /* CIF ENDTEXT */
        /* CIF START (465, 115), (70, 35) */
        START;
            /* CIF task (395, 170), (208, 88) */
            task for y in range (rows):
   for x in range (cols):
      Playground (y)(x) := empty
   endfor
endfor
            /* CIF comment (620, 194), (126, 40) */
            comment 'Clear the grid for 
a new game';
            /* CIF return (482, 278), (35, 35) */
            return ;
    endprocedure;
    /* CIF procedure (155, 66), (73, 35) */
    procedure Rotate;
        /* CIF TEXT (0, 27), (334, 136) */
        fpar
           in source Sprite;
        returns Sprite;
        
        dcl ret Sprite;
        --  Perform a rotation of the shape within its pixel grid
        /* CIF ENDTEXT */
        /* CIF START (457, 50), (70, 35) */
        START;
            /* CIF decision (406, 105), (170, 50) */
            decision Source.Shape /= o_shape;
                /* CIF ANSWER (342, 175), (70, 24) */
                (true):
                    /* CIF task (285, 219), (184, 35) */
                    task Ret.Origin := Source.Origin;
                    /* CIF task (230, 269), (295, 104) */
                    task for y in range (4):
   for x in range (4):
      Ret.Shape (x)(3 - y) := Source.Shape (y)(x)
  endfor
endfor;
                /* CIF ANSWER (560, 175), (70, 24) */
                (false):
                    /* CIF task (544, 219), (100, 40) */
                    task Ret := Source;
            enddecision;
            /* CIF return (474, 389), (35, 35) */
            return ret;
    endprocedure;
    /* CIF procedure (151, 23), (76, 35) */
    procedure Move_To;
        /* CIF TEXT (0, 137), (267, 184) */
        fpar
          in          Dest              Sprite,
          in          Spriteless    Grid,
          in/out Playground Grid;
        
        dcl New_Field Grid;
        
        dcl Ret Move_Status := OK;
        
        returns Move_Status;
        /* CIF ENDTEXT */
        /* CIF START (621, 73), (70, 35) */
        START;
            /* CIF task (576, 128), (159, 35) */
            task New_Field := Spriteless
            /* CIF comment (750, 125), (226, 40) */
            comment 'The Spriteless playground only has
non-moving blocks on the bottom';
            /* CIF task (407, 178), (497, 184) */
            task for y in range (4):
   for x in range (4):
      Ret := (if Dest.Shape (y)(x) /= Empty and
                        (
                          (Dest.Origin.x+x < 0 or Dest.Origin.x + x > 9 or Dest.Origin.y + y >19)
                          or else (New_Field (Dest.Origin.y + y)(Dest.Origin.x + x) /= Empty
                                  and Dest.Shape(y)(x) /= Empty)
                        )
                   then Rejected else Ret fi)
   endfor
endfor
            /* CIF comment (919, 250), (173, 40) */
            comment 'Check that all destination
spots in the grid are free';
            /* CIF decision (628, 393), (55, 50) */
            decision Ret;
                /* CIF ANSWER (438, 463), (70, 24) */
                (OK):
                    /* CIF task (233, 502), (480, 152) */
                    task for y in range (4):
   for x in range (4):
      decision Dest.Shape(y)(x) /= Empty;
       (true): 
           task New_Field (Dest.Origin.y + y)(Dest.Origin.x + x) := Dest.Shape (y)(x);
       (false):
      enddecision;
    endfor
endfor
                    /* CIF comment (733, 558), (134, 40) */
                    comment 'Add the new sprite';
                    /* CIF task (389, 685), (168, 35) */
                    task Playground := New_Field;
                /* CIF ANSWER (910, 463), (75, 24) */
                (Rejected):
            enddecision;
            /* CIF return (638, 736), (35, 35) */
            return Ret;
    endprocedure;
    /* CIF procedure (160, 202), (77, 35) */
    procedure Translate;
        /* CIF TEXT (0, 27), (267, 140) */
        fpar
           in source Coordinates,
           in cmd      Move_Command;
        returns Coordinates;
        
        dcl Res Coordinates;
        /* CIF ENDTEXT */
        /* CIF START (640, 50), (70, 35) */
        START;
            /* CIF decision (640, 105), (70, 50) */
            decision cmd;
                /* CIF ANSWER (405, 175), (70, 24) */
                (down):
                    /* CIF task (385, 219), (109, 72) */
                    task Res := {
  x Source.x,
  y Source.y + 1
};
                /* CIF ANSWER (528, 175), (70, 24) */
                (right):
                    /* CIF task (505, 219), (115, 72) */
                    task Res := {
   x Source.x + 1,
   y Source.y
};
                /* CIF ANSWER (669, 175), (70, 24) */
                (left):
                    /* CIF task (647, 219), (112, 72) */
                    task Res := {
   x Source.x - 1,
   y Source.y
};
                /* CIF ANSWER (815, 175), (70, 24) */
                (rotate):
            enddecision;
            /* CIF return (657, 307), (35, 35) */
            return Res;
    endprocedure;
    /* CIF procedure (153, 153), (125, 35) */
    procedure Print_Playground;
        /* CIF TEXT (33, 59), (267, 140) */
        fpar in Area Grid;
        /* CIF ENDTEXT */
        /* CIF START (503, 133), (70, 35) */
        START;
            /* CIF task (370, 188), (334, 120) */
            task for y in range(rows):
   for x in range(cols):
       call write(if area(y)(x) = Empty then '.' else 'X' fi);
   endfor
   call writeln('');
endfor;
            /* CIF return (520, 339), (35, 35) */
            return ;
    endprocedure;
    /* CIF START (1433, 10), (70, 35) */
    START;
        /* CIF NEXTSTATE (1433, 65), (70, 35) */
        NEXTSTATE Wait;
    /* CIF label (330, 220), (70, 35) */
    connection Move:
        /* CIF decision (257, 275), (216, 72) */
        decision Move_To (Next_Sprite,
                    Landscape,
                    Play_Area);
            /* CIF ANSWER (72, 367), (70, 24) */
            (OK):
                /* CIF task (18, 411), (178, 35) */
                task Prev_Sprite := Next_Sprite;
                /* CIF PROCEDURECALL (0, 466), (215, 35) */
                call Print_Playground (Play_Area);
                /* CIF output (21, 516), (173, 35) */
                output Update_Grid (Play_Area);
                /* CIF NEXTSTATE (62, 566), (90, 35) */
                NEXTSTATE Next_Move;
            /* CIF ANSWER (433, 383), (75, 24) */
            (Rejected):
                /* CIF decision (383, 427), (174, 39) */
                decision Next_Sprite = Prev_Sprite;
                    /* CIF ANSWER (284, 487), (70, 24) */
                    (true):
                        /* CIF PROCEDURECALL (226, 531), (186, 35) */
                        call Reset_Timer (Tetris_Timer);
                        /* CIF output (273, 581), (92, 40) */
                        output Game_Over
(True);
                        /* CIF PROCEDURECALL (245, 641), (147, 35) */
                        call writeln('Game Over');
                        /* CIF NEXTSTATE (284, 691), (70, 35) */
                        NEXTSTATE Wait;
                    /* CIF ANSWER (536, 487), (70, 24) */
                    (false):
                        /* CIF decision (499, 531), (143, 56) */
                        decision Next_Sprite.Origin.y
/=
Prev_Sprite.Origin.y
                        /* CIF comment (661, 531), (156, 56) */
                        comment 'If move command is
Left/Right/Rotate, still
try to go down';
                            /* CIF ANSWER (481, 613), (70, 24) */
                            (True):
                                /* CIF PROCEDURECALL (422, 657), (186, 35) */
                                call Reset_Timer (Tetris_Timer);
                                /* CIF task (448, 707), (135, 35) */
                                task Timer_Value := 500;
                                /* CIF PROCEDURECALL (423, 762), (185, 40) */
                                call set_timer
(Timer_Value, Tetris_Timer);
                                /* CIF NEXTSTATE (470, 822), (90, 35) */
                                NEXTSTATE Next_Block;
                            /* CIF ANSWER (629, 613), (70, 24) */
                            (False):
                                /* CIF NEXTSTATE (619, 657), (90, 35) */
                                NEXTSTATE Next_Move;
                        enddecision;
                enddecision;
        enddecision;
    /* CIF End Label */
    endconnection;
    /* CIF state (1321, 377), (90, 35) */
    state Next_Move;
        /* CIF input (916, 432), (96, 35) */
        input Tetris_Timer;
            /* CIF PROCEDURECALL (871, 487), (185, 40) */
            call Set_Timer
(Timer_Value, Tetris_Timer);
            /* CIF task (829, 542), (270, 40) */
            task Next_Sprite.Origin :=
   call Translate (Prev_Sprite.Origin, Down);
            /* CIF join (946, 602), (35, 35) */
            join Move;
        /* CIF input (1475, 432), (70, 40) */
        input Move
(cmd);
            /* CIF decision (1475, 492), (70, 50) */
            decision cmd;
                /* CIF ANSWER (1167, 562), (70, 24) */
                (rotate):
                    /* CIF task (1115, 606), (173, 40) */
                    task Next_Sprite :=
  call Rotate (Prev_Sprite);
                /* CIF ANSWER (1332, 562), (70, 24) */
                (down):
                    /* CIF task (1299, 606), (135, 35) */
                    task Timer_Value := 100;
                /* CIF ANSWER (1541, 562), (70, 24) */
                (left):
                    /* CIF task (1446, 606), (260, 40) */
                    task Next_Sprite.Origin :=
   call Translate (Prev_Sprite.Origin, Left);
                /* CIF ANSWER (1817, 562), (70, 24) */
                (right):
                    /* CIF task (1718, 606), (268, 40) */
                    task Next_Sprite.Origin :=
   call Translate (Prev_Sprite.Origin, Right);
            enddecision;
            /* CIF join (1492, 662), (35, 35) */
            join Move;
    endstate;
    /* CIF state (1433, 65), (70, 35) */
    state Wait;
        /* CIF input (1423, 120), (90, 40) */
        input New_Game
 (foo);
            /* CIF PROCEDURECALL (1368, 180), (200, 35) */
            call Clear_Playground (Play_Area);
            /* CIF PROCEDURECALL (1375, 230), (185, 40) */
            call set_timer
(Timer_Value, Tetris_Timer);
            /* CIF NEXTSTATE (1423, 290), (90, 35) */
            NEXTSTATE Next_Block;
    endstate;
    /* CIF state (2271, 12), (90, 35) */
    state Next_Block;
        /* CIF input (2264, 67), (103, 35) */
        input Tetris_Timer;
            /* CIF task (2235, 122), (160, 35) */
            task Landscape := Play_Area;
            /* CIF task (2215, 172), (201, 35) */
            task Prev_Sprite.Origin := { x 4, y 0 };
            /* CIF decision (2281, 222), (70, 50) */
            decision any
            /* CIF comment (2371, 229), (126, 40) */
            comment 'Choose randomly
the next brick';
                /* CIF ANSWER (1794, 292), (70, 24) */
                ('t brick'):
                    /* CIF task (1757, 336), (144, 40) */
                    task Prev_Sprite.Shape :=
   t_shape;
                /* CIF ANSWER (1949, 292), (70, 24) */
                ('l brick'):
                    /* CIF task (1912, 336), (144, 40) */
                    task Prev_Sprite.Shape :=
   l_shape;
                /* CIF ANSWER (2104, 292), (70, 24) */
                ('j brick'):
                    /* CIF task (2067, 336), (144, 40) */
                    task Prev_Sprite.Shape :=
   j_shape;
                /* CIF ANSWER (2259, 292), (70, 24) */
                ('s brick'):
                    /* CIF task (2222, 336), (144, 40) */
                    task Prev_Sprite.Shape :=
   s_shape;
                /* CIF ANSWER (2414, 292), (70, 24) */
                ('z brick'):
                    /* CIF task (2377, 336), (144, 40) */
                    task Prev_Sprite.Shape :=
   z_shape;
                /* CIF ANSWER (2570, 292), (70, 24) */
                ('i brick'):
                    /* CIF task (2533, 336), (144, 40) */
                    task Prev_Sprite.Shape :=
   i_shape;
                /* CIF ANSWER (2725, 292), (70, 24) */
                ('o brick'):
                    /* CIF task (2688, 336), (144, 40) */
                    task Prev_Sprite.Shape :=
   o_shape;
            enddecision;
            /* CIF task (2224, 392), (184, 35) */
            task Next_Sprite := Prev_Sprite;
            /* CIF PROCEDURECALL (2223, 447), (185, 40) */
            call Set_Timer
(Timer_Value, Tetris_Timer);
            /* CIF join (2298, 502), (35, 35) */
            join Move;
    endstate;
endprocess Engine;